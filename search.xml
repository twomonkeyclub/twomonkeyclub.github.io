<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【TinyWebServer】工作两年，回看WebServer</title>
    <url>/posts/f9d605ee/</url>
    <content><![CDATA[<p>TinyWebserver是Web服务器吗？Web服务器、Web框架和应用服务器有什么区别？不同开发语言下的Web技术栈本质是否相通？</p>
<span id="more"></span>
<p>你好，我是社长。</p>
<p>作为公众号的老朋友，我从2020年初开始写文章，大概四个月的时间，更新了《TinyWebServer》《UART》两个系列文章，之后便”消失”了两年的时间。 </p>
<p>“消失”的这段时间，除了被迫学习，忙工作上的事情外，其实一直在关注网络上对于TinyWebServer的讨论。今天，我想从Web服务器，Web框架，应用服务器的角度和大家再聊一聊WebServer。</p>
<h2 id="TinyWebServer现状"><a href="#TinyWebServer现状" class="headerlink" title="TinyWebServer现状"></a>TinyWebServer现状</h2><p>如果是学习C++的新同学，我想你大概率听说过WebServer，也许更熟悉的，是许多同学嘴边那句”烂大街的Web服务器”。</p>
<p>C++服务器变成校招简历常客，应该是在19年linyacool开源WebServer项目之后，如果说是谁造成了WebServer烂大街，我想TinyWebServer应该是有一点责任的。</p>
<p>那时候TinyWebServer还是个只有几十星的repo，随着项目详解的更新和同学们的口口相传，现在的TinyWebServer已经是一个8.5K星星的项目了。虽然上过几个公众号的热榜，但我总有一种被大家错爱的感觉，以前大多是因为项目大部分代码在书上都可以找到，工作后我慢慢发现项目好像存在一些问题。</p>
<h2 id="TinyWebServer是Web服务器吗？"><a href="#TinyWebServer是Web服务器吗？" class="headerlink" title="TinyWebServer是Web服务器吗？"></a>TinyWebServer是Web服务器吗？</h2><p>群里的朋友应该知道，我今年从深圳某大厂离职回到了成都。之前在深圳，我的语言是Python&#x2F;Golang，偶尔也会维护PHP的代码。</p>
<h2 id="web服务器和web框架"><a href="#web服务器和web框架" class="headerlink" title="web服务器和web框架"></a>web服务器和web框架</h2><p>python开发环境下，两者都是必须的</p>
<ul>
<li>Web服务器<ul>
<li>处理网络IO，通过响应html页面来处理http请求</li>
<li>只能用来处理http请求</li>
</ul>
</li>
<li>应用服务器<ul>
<li>除http协议外，还支持其他协议</li>
</ul>
</li>
<li>Web框架</li>
</ul>
<h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><ul>
<li>为什么不同的语言部署方式不同？<ul>
<li>解释性语言一定会有特殊的web服务器吗？python有uwsgi</li>
<li>python<ul>
<li>nginx + uwsgi + django</li>
<li>nginx + gunicorn + uvicorn + fastapi</li>
<li>…</li>
</ul>
</li>
<li>golang<ul>
<li>二进制文件部署</li>
</ul>
</li>
<li>java<ul>
<li>nginx + tomcat + springboot</li>
</ul>
</li>
<li>php<ul>
<li>nginx + php-fm</li>
</ul>
</li>
</ul>
</li>
<li>项目中的cgi是什么，你为什么删掉了？删掉之后还是webserver吗？</li>
</ul>
<h2 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h2><ul>
<li>CGI<ul>
<li>为什么会出现</li>
<li>是什么东西</li>
<li>怎么用</li>
</ul>
</li>
<li>fastcgi<ul>
<li></li>
</ul>
</li>
</ul>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>wsgi是个应用程序服务器进程内调用应用程序使用的接口规范，是针对python语言的；<br>uwsgi fastcgi scgi 则是web服务器与应用程序服务器进程间使用的协议，与语言无关</p>
<h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><ul>
<li>golang需要独立的web服务器吗？go本身就可以很好的支持</li>
</ul>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【UART】详解 - 01 UART</title>
    <url>/posts/277b0a9d/</url>
    <content><![CDATA[<p>测试占位</p>
<span id="more"></span>]]></content>
      <categories>
        <category>UART</category>
      </categories>
  </entry>
  <entry>
    <title>如何评估镜像的资源占用</title>
    <url>/posts/f31a4c15/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 01 线程同步机制包装类</title>
    <url>/posts/336d3217/</url>
    <content><![CDATA[<p>线程同步机制包装类</p>
<span id="more"></span>

<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a><strong><span  style="color: #00ACC1; ">RAII</span></strong></h4><ul>
<li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.</li>
<li>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定</li>
<li>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子</li>
</ul>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong><span  style="color: #00ACC1; ">信号量</span></strong></h4><p>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：</p>
<blockquote>
<ul>
<li>P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行</li>
<li>V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一</li>
</ul>
</blockquote>
<p>信号量的取值可以是任何自然数，最常用的，最简单的信号量是二进制信号量，只有0和1两个值.</p>
<blockquote>
<ul>
<li>sem_init函数用于初始化一个未命名的信号量</li>
<li>sem_destory函数用于销毁信号量</li>
<li>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</li>
<li>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a><strong><span  style="color: #00ACC1; ">互斥量</span></strong></h4><p>互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,唤醒等待该互斥锁的线程.</p>
<blockquote>
<ul>
<li>pthread_mutex_init函数用于初始化互斥锁</li>
<li>pthread_mutex_destory函数用于销毁互斥锁</li>
<li>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</li>
<li>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a><strong><span  style="color: #00ACC1; ">条件变量</span></strong></h4><p>条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.</p>
<blockquote>
<ul>
<li>pthread_cond_init函数用于初始化条件变量</li>
<li>pthread_cond_destory函数销毁条件变量</li>
<li>pthread_cond_broadcast函数以广播的方式唤醒<strong>所有</strong>等待目标条件变量的线程</li>
<li>pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 <strong>mutex参数(加锁的互斥锁)</strong> ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. <strong>也就是说函数内部会有一次解锁和加锁操作</strong>.</li>
</ul>
</blockquote>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="锁机制的功能"><a href="#锁机制的功能" class="headerlink" title="锁机制的功能"></a><strong><span  style="color: #00ACC1; ">锁机制的功能</span></strong></h4><ul>
<li>实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段.</li>
</ul>
<h4 id="封装的功能"><a href="#封装的功能" class="headerlink" title="封装的功能"></a><strong><span  style="color: #00ACC1; ">封装的功能</span></strong></h4><ul>
<li>类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">sem</span>()</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//信号量初始化</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sem_init</span>(&amp;m_sem,<span class="number">0</span>,<span class="number">0</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//析构函数</span></span><br><span class="line">        ~<span class="built_in">sem</span>()</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//信号量销毁</span></span><br><span class="line">            <span class="built_in">sem_destroy</span>(&amp;m_sem);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将重复使用的代码封装为函数，减少代码的重复，使其更简洁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件变量的使用机制需要配合锁来使用</span></span><br><span class="line"><span class="comment">//内部会有一次加锁和解锁</span></span><br><span class="line"><span class="comment">//封装起来会使得更加简洁</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    ret=<span class="built_in">pthread_cond_wait</span>(&amp;m_cond,&amp;m_mutex);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">return</span> ret==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 02 半同步半反应堆线程池（上）</title>
    <url>/posts/6a66ce4/</url>
    <content><![CDATA[<p>半同步半反应堆线程池（上）</p>
<span id="more"></span>
<p>本次讲解线程池所涉及的基础知识，包括服务器基本框架、I&#x2F;O模型、事件处理模式等。</p>
<p>主要围绕服务器项目中涉及的知识进行介绍，若想了解更多相关知识，请参考<strong>《Linux下高性能服务器编程》</strong>。</p>
<h3 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a>服务器编程基本框架</h3><p>主要由I&#x2F;O单元，逻辑单元和网络存储单元组成，其中每个单元之间通过请求队列进行通信，从而协同完成任务。</p>
<p>其中I&#x2F;O单元用于处理客户端连接，读写网络数据；逻辑单元用于处理业务逻辑的线程；网络存储单元指本地数据库和文件等。</p>
<div align=center><img src="http://ww1.sinaimg.cn/large/005TJ2c7ly1gcjuj8nbqnj30g006gt8u.jpg" height="200"/> </div>

<h3 id="五种I-x2F-O模型"><a href="#五种I-x2F-O模型" class="headerlink" title="五种I&#x2F;O模型"></a>五种I&#x2F;O模型</h3><ul>
<li><strong>阻塞IO</strong>:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</li>
<li><strong>非阻塞IO</strong>:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain</li>
<li><strong>信号驱动IO</strong>:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li>
<li><strong>IO复用</strong>:linux用select&#x2F;poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</li>
<li><strong>异步IO</strong>:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</li>
</ul>
<p><strong>注意：阻塞I&#x2F;O，非阻塞I&#x2F;O，信号驱动I&#x2F;O和I&#x2F;O复用都是同步I&#x2F;O。同步I&#x2F;O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作，异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作。</strong></p>
<h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><ul>
<li>reactor模式中，主线程(<strong>I&#x2F;O处理单元</strong>)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(<strong>逻辑单元</strong> )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由<strong>同步I&#x2F;O</strong>实现。</li>
<li>proactor模式中，主线程和内核负责处理读写数据、接受新连接等I&#x2F;O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由<strong>异步I&#x2F;O</strong>实现。</li>
</ul>
<h3 id="同步I-x2F-O模拟proactor模式"><a href="#同步I-x2F-O模拟proactor模式" class="headerlink" title="同步I&#x2F;O模拟proactor模式"></a>同步I&#x2F;O模拟proactor模式</h3><p>由于异步I&#x2F;O并不成熟，实际中使用较少，这里将使用同步I&#x2F;O模拟实现proactor模式。</p>
<p>同步I&#x2F;O模型的工作流程如下（epoll_wait为例）：</p>
<blockquote>
<ul>
<li>主线程往epoll内核事件表注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ul>
</blockquote>
<h3 id="并发编程模式"><a href="#并发编程模式" class="headerlink" title="并发编程模式"></a>并发编程模式</h3><p>并发编程方法的实现有多线程和多进程两种，但这里涉及的并发模式指I&#x2F;O处理单元与逻辑单元的协同完成任务的方法。</p>
<ul>
<li>半同步&#x2F;半异步模式</li>
<li>领导者&#x2F;追随者模式</li>
</ul>
<h3 id="半同步-x2F-半反应堆"><a href="#半同步-x2F-半反应堆" class="headerlink" title="半同步&#x2F;半反应堆"></a>半同步&#x2F;半反应堆</h3><p>半同步&#x2F;半反应堆并发模式是半同步&#x2F;半异步的变体，将半异步具体化为某种事件处理模式.</p>
<p>并发模式中的同步和异步</p>
<blockquote>
<ul>
<li>同步指的是程序完全按照代码序列的顺序执行</li>
<li>异步指的是程序的执行需要由系统事件驱动</li>
</ul>
</blockquote>
<p>半同步&#x2F;半异步模式工作流程</p>
<blockquote>
<ul>
<li>同步线程用于处理客户逻辑</li>
<li>异步线程用于处理I&#x2F;O事件</li>
<li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li>
<li>请求队列将通知某个工作在<strong>同步模式的工作线程</strong>来读取并处理该请求对象</li>
</ul>
</blockquote>
<p>半同步&#x2F;半反应堆工作流程（以Proactor模式为例）</p>
<blockquote>
<ul>
<li>主线程充当异步线程，负责监听所有socket上的事件</li>
<li>若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件</li>
<li>如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中</li>
<li>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li>
</ul>
</blockquote>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li>
<li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li>
<li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li>
<li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li>
</ul>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 03 半同步半反应堆线程池（下）</title>
    <url>/posts/560d9b20/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a><strong><span  style="color: #00ACC1; ">静态成员变量</span></strong></h4><p>将类成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。</p>
<p>静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区。</p>
<ul>
<li>静态成员变量<ul>
<li>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。</li>
<li>无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。</li>
<li>非静态成员类外不能初始化。</li>
<li>静态成员数据是共享的。</li>
</ul>
</li>
</ul>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a><strong><span  style="color: #00ACC1; ">静态成员函数</span></strong></h4><p>将类成员函数声明为static，则为静态成员函数。</p>
<ul>
<li>静态成员函数<ul>
<li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。</li>
<li>普通成员函数可以访问普通成员变量，也可以访问静态成员变量。</li>
<li>静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。</li>
</ul>
</li>
</ul>
<h4 id="pthread-create陷阱"><a href="#pthread-create陷阱" class="headerlink" title="pthread_create陷阱"></a><strong><span  style="color: #00ACC1; ">pthread_create陷阱</span></strong></h4><p>首先看一下该函数的函数原型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span> <span class="params">(<span class="type">pthread_t</span> *thread_tid, 				<span class="comment">//返回新生成的线程的id</span></span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,			<span class="comment">//指向线程属性的指针,通常设置为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">void</span> * (*start_routine) (<span class="type">void</span> *), 	<span class="comment">//处理线程函数的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">void</span> *arg)</span></span>;							<span class="comment">//start_routine()中的参数</span></span><br></pre></td></tr></table></figure>
<p>函数原型中的第三个参数，为函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数为类成员函数时，需要将其设置为<strong>静态成员函数</strong>。</p>
<h4 id="this指针的锅"><a href="#this指针的锅" class="headerlink" title="this指针的锅"></a>this指针的锅</h4><p>pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为<code>(void *)</code>,若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数<code>(void*)</code>不能匹配，不能通过编译。</p>
<p>静态成员函数就没有这个问题，里面没有this指针。</p>
<h3 id="线程池分析"><a href="#线程池分析" class="headerlink" title="线程池分析"></a>线程池分析</h3><p>线程池的设计模式为半同步&#x2F;半反应堆，其中反应堆具体为Proactor事件处理模式。</p>
<p>具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。</p>
<h4 id="线程池类定义"><a href="#线程池类定义" class="headerlink" title="线程池类定义"></a><strong><span  style="color: #00ACC1; ">线程池类定义</span></strong></h4><p>具体定义可以看代码。需要注意，线程处理函数和运行函数设置为私有属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//thread_number是线程池中线程的数量</span></span><br><span class="line">		<span class="comment">//max_requests是请求队列中最多允许的、等待处理的请求的数量</span></span><br><span class="line">		<span class="comment">//connPool是数据库连接池指针</span></span><br><span class="line">    	<span class="built_in">threadpool</span>(connection_pool *connPool, <span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">        ~<span class="built_in">threadpool</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//像请求队列中插入任务请求</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//工作线程运行的函数</span></span><br><span class="line">		<span class="comment">//它不断从工作队列中取出任务并执行之</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">worker</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">//线程池中的线程数</span></span><br><span class="line">        <span class="type">int</span> m_thread_number;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//请求队列中允许的最大请求数</span></span><br><span class="line">        <span class="type">int</span> m_max_requests;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//描述线程池的数组，其大小为m_thread_number</span></span><br><span class="line">        <span class="type">pthread_t</span> *m_threads;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//请求队列</span></span><br><span class="line">        std::list&lt;T *&gt;m_workqueue;	</span><br><span class="line"></span><br><span class="line">		<span class="comment">//保护请求队列的互斥锁	</span></span><br><span class="line">        locker m_queuelocker;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//是否有任务需要处理</span></span><br><span class="line">        sem m_queuestat;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//是否结束线程</span></span><br><span class="line">        <span class="type">bool</span> m_stop;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//数据库连接池</span></span><br><span class="line">		connection_pool *m_connPool;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="线程池创建与回收"><a href="#线程池创建与回收" class="headerlink" title="线程池创建与回收"></a><strong><span  style="color: #00ACC1; ">线程池创建与回收</span></strong></h4><p>构造函数中创建线程池,pthread_create函数中将类的对象作为参数传递给静态函数(worker),在静态函数中引用这个对象,并调用其动态方法(run)。</p>
<p>具体的，类对象传递时用this指针，传递给静态函数后，将其转换为线程池类，并调用私有成员函数run。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::<span class="built_in">threadpool</span>( connection_pool *connPool, <span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : <span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), <span class="built_in">m_stop</span>(<span class="literal">false</span>), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>),<span class="built_in">m_connPool</span>(connPool)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(thread_number&lt;=<span class="number">0</span>||max_requests&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程id初始化</span></span><br><span class="line">    m_threads=<span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];</span><br><span class="line">    <span class="keyword">if</span>(!m_threads)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;thread_number;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环创建线程，并将工作线程按要求进行运行</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(m_threads+i,<span class="literal">NULL</span>,worker,<span class="keyword">this</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将线程进行分离后，不用单独对工作线程进行回收</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_detach</span>(m_threads[i]))&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="向请求队列中添加任务"><a href="#向请求队列中添加任务" class="headerlink" title="向请求队列中添加任务"></a><strong><span  style="color: #00ACC1; ">向请求队列中添加任务</span></strong></h4><p>通过list容器创建请求队列，向队列中添加时，通过互斥锁保证线程安全，添加完成后通过信号量提醒有任务要处理，最后注意线程同步。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">append</span>(T* request)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据硬件，预先设置请求队列的最大值</span></span><br><span class="line">    <span class="keyword">if</span>(m_workqueue.<span class="built_in">size</span>()&gt;m_max_requests)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加任务</span></span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//信号量提醒有任务要处理</span></span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="线程处理函数"><a href="#线程处理函数" class="headerlink" title="线程处理函数"></a><strong><span  style="color: #00ACC1; ">线程处理函数</span></strong></h4><p>内部访问私有成员函数run，完成线程处理要求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span>* arg)&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将参数强转为线程池类，调用成员方法</span></span><br><span class="line">    threadpool* pool=(threadpool*)arg;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="run执行任务"><a href="#run执行任务" class="headerlink" title="run执行任务"></a><strong><span  style="color: #00ACC1; ">run执行任务</span></strong></h4><p>主要实现，工作线程从请求队列中取出某个任务进行处理，注意线程同步。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!m_stop)</span><br><span class="line">    &#123;	</span><br><span class="line">		<span class="comment">//信号量等待</span></span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//被唤醒后先加互斥锁</span></span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_workqueue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从请求队列中取出第一个任务</span></span><br><span class="line">		<span class="comment">//将任务从请求队列删除</span></span><br><span class="line">        T* request=m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(!request)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//从连接池中取出一个数据库连接</span></span><br><span class="line">        request-&gt;mysql = m_connPool-&gt;<span class="built_in">GetConnection</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//process(模板类中的方法,这里是http类)进行处理</span></span><br><span class="line">        request-&gt;<span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将数据库连接放回连接池</span></span><br><span class="line">        m_connPool-&gt;<span class="built_in">ReleaseConnection</span>(request-&gt;mysql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 05 http连接处理（中）</title>
    <url>/posts/9babb07/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>上篇，我们对http连接的基础知识、服务器接收请求的处理流程进行了介绍，本篇将结合流程图和代码分别对状态机和服务器解析请求报文进行详解。</p>
<p><strong>流程图部分</strong>，描述主、从状态机调用关系与状态转移过程。</p>
<p><strong>代码部分</strong>，结合代码对http请求报文的解析进行详解。</p>
<hr>
<h3 id="流程图与状态机"><a href="#流程图与状态机" class="headerlink" title="流程图与状态机"></a>流程图与状态机</h3><p><strong>从状态机负责读取报文的一行，主状态机负责对该行数据进行解析</strong>，主状态机内部调用从状态机，从状态机驱动主状态机。</p>
<div align=center><img src="http://ww1.sinaimg.cn/large/005TJ2c7ly1gdec5mnveqj31b10loadk.jpg" height="350"/> </div>

<h4 id="主状态机"><a href="#主状态机" class="headerlink" title="主状态机"></a><strong><span  style="color: #00ACC1; ">主状态机</span></strong></h4><p>三种状态，标识解析位置。</p>
<ul>
<li>CHECK_STATE_REQUESTLINE，解析请求行</li>
<li>CHECK_STATE_HEADER，解析请求头</li>
<li>CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求</li>
</ul>
<h4 id="从状态机"><a href="#从状态机" class="headerlink" title="从状态机"></a><strong><span  style="color: #00ACC1; ">从状态机</span></strong></h4><p>三种状态，标识解析一行的读取状态。</p>
<ul>
<li>LINE_OK，完整读取一行</li>
<li>LINE_BAD，报文语法有误</li>
<li>LINE_OPEN，读取的行不完整</li>
</ul>
<hr>
<h3 id="代码分析-http报文解析"><a href="#代码分析-http报文解析" class="headerlink" title="代码分析-http报文解析"></a>代码分析-http报文解析</h3><p>上篇中介绍了服务器接收http请求的流程与细节，简单来讲，浏览器端发出http连接请求，服务器端主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列后，工作线程从任务队列中取出一个任务进行处理。</p>
<p>各子线程通过process函数对任务进行处理，调用process_read函数和process_write函数分别完成报文解析与报文响应两个任务。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HTTP_CODE read_ret=<span class="built_in">process_read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//NO_REQUEST，表示请求不完整，需要继续接收请求数据</span></span><br><span class="line">    <span class="keyword">if</span>(read_ret==NO_REQUEST)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//注册并监听读事件</span></span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用process_write完成报文响应</span></span><br><span class="line">    <span class="type">bool</span> write_ret=<span class="built_in">process_write</span>(read_ret);</span><br><span class="line">    <span class="keyword">if</span>(!write_ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close_conn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//注册并监听写事件</span></span><br><span class="line">    <span class="built_in">modfd</span>(m_epollfd,m_sockfd,EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本篇将对<strong>报文解析的流程和process_read函数细节</strong>进行详细介绍。</p>
<h4 id="HTTP-CODE含义"><a href="#HTTP-CODE含义" class="headerlink" title="HTTP_CODE含义"></a><strong><span  style="color: #00ACC1; ">HTTP_CODE含义</span></strong></h4><p>表示HTTP请求的处理结果，在头文件中初始化了八种情形，在报文解析时只涉及到四种。</p>
<ul>
<li>NO_REQUEST<ul>
<li>请求不完整，需要继续读取请求报文数据</li>
</ul>
</li>
<li>GET_REQUEST<ul>
<li>获得了完整的HTTP请求</li>
</ul>
</li>
<li>BAD_REQUEST<ul>
<li>HTTP请求报文有语法错误</li>
</ul>
</li>
<li>INTERNAL_ERROR<ul>
<li>服务器内部错误，该结果在主状态机逻辑switch的default下，一般不会触发</li>
</ul>
</li>
</ul>
<h4 id="解析报文整体流程"><a href="#解析报文整体流程" class="headerlink" title="解析报文整体流程"></a><strong><span  style="color: #00ACC1; ">解析报文整体流程</span></strong></h4><p>process_read通过while循环，将主从状态机进行封装，对报文的每一行进行循环处理。</p>
<ul>
<li>判断条件<ul>
<li>主状态机转移到CHECK_STATE_CONTENT，该条件涉及解析消息体</li>
<li>从状态机转移到LINE_OK，该条件涉及解析请求行和请求头部</li>
<li>两者为或关系，当条件为真则继续循环，否则退出</li>
</ul>
</li>
<li>循环体<ul>
<li>从状态机读取数据</li>
<li>调用get_line函数，通过m_start_line将从状态机读取数据间接赋给text</li>
<li>主状态机解析text</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//m_start_line是行在buffer中的起始位置，将该位置后面的数据赋给text</span></span><br><span class="line"><span class="comment">//此时从状态机已提前将一行的末尾字符\r\n变为\0\0，所以text可以直接取出完整的行进行解析</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">get_line</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_read_buf+m_start_line;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化从状态机状态、HTTP请求解析结果</span></span><br><span class="line">    LINE_STATUS line_status=LINE_OK;</span><br><span class="line">    HTTP_CODE ret=NO_REQUEST;</span><br><span class="line">    <span class="type">char</span>* text=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里为什么要写两个判断条件？第一个判断条件为什么这样写？</span></span><br><span class="line">	<span class="comment">//具体的在主状态机逻辑中会讲解。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//parse_line为从状态机的具体实现</span></span><br><span class="line">    <span class="keyword">while</span>((m_check_state==CHECK_STATE_CONTENT &amp;&amp; line_status==LINE_OK)||((line_status=<span class="built_in">parse_line</span>())==LINE_OK))</span><br><span class="line">    &#123;</span><br><span class="line">        text=<span class="built_in">get_line</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//m_start_line是每一个数据行在m_read_buf中的起始位置</span></span><br><span class="line">		<span class="comment">//m_checked_idx表示从状态机在m_read_buf中读取的位置</span></span><br><span class="line">        m_start_line=m_checked_idx;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//主状态机的三种状态转移逻辑</span></span><br><span class="line">        <span class="keyword">switch</span>(m_check_state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_REQUESTLINE:</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//解析请求行</span></span><br><span class="line">                ret=<span class="built_in">parse_request_line</span>(text);</span><br><span class="line">                <span class="keyword">if</span>(ret==BAD_REQUEST)</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_HEADER:</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//解析请求头</span></span><br><span class="line">                ret=<span class="built_in">parse_headers</span>(text);</span><br><span class="line">                <span class="keyword">if</span>(ret==BAD_REQUEST)</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//完整解析GET请求后，跳转到报文响应函数</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ret==GET_REQUEST)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_CONTENT:</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//解析消息体</span></span><br><span class="line">                ret=<span class="built_in">parse_content</span>(text);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//完整解析POST请求后，跳转到报文响应函数</span></span><br><span class="line">                <span class="keyword">if</span>(ret==GET_REQUEST)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line"></span><br><span class="line">				<span class="comment">//解析完消息体即完成报文解析，避免再次进入循环，更新line_status</span></span><br><span class="line">                line_status=LINE_OPEN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从状态机逻辑"><a href="#从状态机逻辑" class="headerlink" title="从状态机逻辑"></a><strong><span  style="color: #00ACC1; ">从状态机逻辑</span></strong></h4><p>上一篇的基础知识讲解中，对于HTTP报文的讲解遗漏了一点细节，在这里作为补充。</p>
<p>在HTTP报文中，每一行的数据由\r\n作为结束字符，空行则是仅仅是字符\r\n。因此，可以通过查找\r\n将报文拆解成单独的行进行解析，项目中便是利用了这一点。</p>
<p>从状态机负责读取buffer中的数据，将每行数据末尾的\r\n置为\0\0，并更新从状态机在buffer中读取的位置m_checked_idx，以此来驱动主状态机解析。</p>
<ul>
<li>从状态机从m_read_buf中逐字节读取，判断当前字节是否为\r<ul>
<li>接下来的字符是\n，将\r\n修改成\0\0，将m_checked_idx指向下一行的开头，则返回LINE_OK</li>
<li>接下来达到了buffer末尾，表示buffer还需要继续接收，返回LINE_OPEN</li>
<li>否则，表示语法错误，返回LINE_BAD</li>
</ul>
</li>
<li>当前字节不是\r，判断是否是\n（<strong>一般是上次读取到\r就到了buffer末尾，没有接收完整，再次接收时会出现这种情况</strong>）<ul>
<li>如果前一个字符是\r，则将\r\n修改成\0\0，将m_checked_idx指向下一行的开头，则返回LINE_OK</li>
</ul>
</li>
<li>当前字节既不是\r，也不是\n<ul>
<li>表示接收不完整，需要继续接收，返回LINE_OPEN</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//从状态机，用于分析出一行内容</span></span><br><span class="line"><span class="comment">//返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m_read_idx指向缓冲区m_read_buf的数据末尾的下一个字节</span></span><br><span class="line"><span class="comment">//m_checked_idx指向从状态机当前正在分析的字节</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(;m_checked_idx&lt;m_read_idx;++m_checked_idx)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//temp为将要分析的字节</span></span><br><span class="line">        temp=m_read_buf[m_checked_idx];</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//如果当前是\r字符，则有可能会读取到完整行</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//下一个字符达到了buffer结尾，则接收不完整，需要继续接收</span></span><br><span class="line">            <span class="keyword">if</span>((m_checked_idx+<span class="number">1</span>)==m_read_idx)</span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">			<span class="comment">//下一个字符是\n，将\r\n改为\0\0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m_read_buf[m_checked_idx+<span class="number">1</span>]==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                m_read_buf[m_checked_idx++]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果都不符合，则返回语法错误</span></span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果当前字符是\n，也有可能读取到完整行</span></span><br><span class="line">		<span class="comment">//一般是上次读取到\r就到buffer末尾了，没有接收完整，再次接收时会出现这种情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//前一个字符是\r，则接收完整</span></span><br><span class="line">            <span class="keyword">if</span>(m_checked_idx&gt;<span class="number">1</span>&amp;&amp;m_read_buf[m_checked_idx<span class="number">-1</span>]==<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_read_buf[m_checked_idx<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//并没有找到\r\n，需要继续接收</span></span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主状态机逻辑"><a href="#主状态机逻辑" class="headerlink" title="主状态机逻辑"></a><strong><span  style="color: #00ACC1; ">主状态机逻辑</span></strong></h4><p>主状态机初始状态是CHECK_STATE_REQUESTLINE，通过调用从状态机来驱动主状态机，在主状态机进行解析前，从状态机已经将每一行的末尾\r\n符号改为\0\0，以便于主状态机直接取出对应字符串进行处理。</p>
<ul>
<li>CHECK_STATE_REQUESTLINE<ul>
<li>主状态机的初始状态，调用parse_request_line函数解析请求行</li>
<li>解析函数从m_read_buf中解析HTTP请求行，获得请求方法、目标URL及HTTP版本号</li>
<li>解析完成后主状态机的状态变为CHECK_STATE_HEADER</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//解析http请求行，获得请求方法，目标url及http版本号</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//在HTTP报文中，请求行用来说明请求类型,要访问的资源以及所使用的HTTP版本，其中各个部分之间通过\t或空格分隔。</span></span><br><span class="line">	<span class="comment">//请求行中最先含有空格和\t任一字符的位置并返回</span></span><br><span class="line">    m_url=<span class="built_in">strpbrk</span>(text,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果没有空格或\t，则报文格式有误</span></span><br><span class="line">    <span class="keyword">if</span>(!m_url)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将该位置改为\0，用于将前面数据取出</span></span><br><span class="line">    *m_url++=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取出数据，并通过与GET和POST比较，以确定请求方式</span></span><br><span class="line">    <span class="type">char</span> *method=text;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(method,<span class="string">&quot;GET&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        m_method=GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(method,<span class="string">&quot;POST&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_method=POST;</span><br><span class="line">        cgi=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m_url此时跳过了第一个空格或\t字符，但不知道之后是否还有</span></span><br><span class="line">	<span class="comment">//将m_url向后偏移，通过查找，继续跳过空格和\t字符，指向请求资源的第一个字符</span></span><br><span class="line">    m_url+=<span class="built_in">strspn</span>(m_url,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用与判断请求方式的相同逻辑，判断HTTP版本号</span></span><br><span class="line">    m_version=<span class="built_in">strpbrk</span>(m_url,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!m_version)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    *m_version++=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    m_version+=<span class="built_in">strspn</span>(m_version,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//仅支持HTTP/1.1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(m_version,<span class="string">&quot;HTTP/1.1&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对请求资源前7个字符进行判断</span></span><br><span class="line">	<span class="comment">//这里主要是有些报文的请求资源中会带有http://，这里需要对这种情况进行单独处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncasecmp</span>(m_url,<span class="string">&quot;http://&quot;</span>,<span class="number">7</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url+=<span class="number">7</span>;</span><br><span class="line">        m_url=<span class="built_in">strchr</span>(m_url,<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//同样增加https情况</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strncasecmp</span>(m_url,<span class="string">&quot;https://&quot;</span>,<span class="number">8</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url+=<span class="number">8</span>;</span><br><span class="line">        m_url=<span class="built_in">strchr</span>(m_url,<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//一般的不会带有上述两种符号，直接是单独的/或/后面带访问资源</span></span><br><span class="line">    <span class="keyword">if</span>(!m_url||m_url[<span class="number">0</span>]!=<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当url为/时，显示欢迎界面</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(m_url)==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(m_url,<span class="string">&quot;judge.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请求行处理完毕，将主状态机转移处理请求头</span></span><br><span class="line">    m_check_state=CHECK_STATE_HEADER;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析完请求行后，主状态机继续分析请求头。在报文中，请求头和空行的处理使用的同一个函数，这里通过判断当前的text首位是不是\0字符，若是，则表示当前处理的是空行，若不是，则表示当前处理的是请求头。</p>
<ul>
<li>CHECK_STATE_HEADER<ul>
<li>调用parse_headers函数解析请求头部信息</li>
<li>判断是空行还是请求头，若是空行，进而判断content-length是否为0，如果不是0，表明是POST请求，则状态转移到CHECK_STATE_CONTENT，否则说明是GET请求，则报文解析结束。</li>
<li>若解析的是请求头部字段，则主要分析connection字段，content-length字段，其他字段可以直接跳过，各位也可以根据需求继续分析。</li>
<li>connection字段判断是keep-alive还是close，决定是长连接还是短连接</li>
<li>content-length字段，这里用于读取post请求的消息体长度</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//解析http请求的一个头部信息</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//判断是空行还是请求头</span></span><br><span class="line">    <span class="keyword">if</span>(text[<span class="number">0</span>]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//判断是GET还是POST请求</span></span><br><span class="line">        <span class="keyword">if</span>(m_content_length!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//POST需要跳转到消息体处理状态</span></span><br><span class="line">            m_check_state=CHECK_STATE_CONTENT;</span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解析请求头部连接字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncasecmp</span>(text,<span class="string">&quot;Connection:&quot;</span>,<span class="number">11</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text+=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//跳过空格和\t字符</span></span><br><span class="line">        text+=<span class="built_in">strspn</span>(text,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(text,<span class="string">&quot;keep-alive&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//如果是长连接，则将linger标志设置为true</span></span><br><span class="line">            m_linger=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解析请求头部内容长度字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncasecmp</span>(text,<span class="string">&quot;Content-length:&quot;</span>,<span class="number">15</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text+=<span class="number">15</span>;</span><br><span class="line">        text+=<span class="built_in">strspn</span>(text,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_content_length=<span class="built_in">atol</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解析请求头部HOST字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncasecmp</span>(text,<span class="string">&quot;Host:&quot;</span>,<span class="number">5</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text+=<span class="number">5</span>;</span><br><span class="line">        text+=<span class="built_in">strspn</span>(text,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_host=text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;oop!unknow header: %s\n&quot;</span>,text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仅仅是GET请求，如项目中的欢迎界面，那么主状态机只设置之前的两个状态足矣。</p>
<p>因为在上篇推文中我们曾说道，GET和POST请求报文的区别之一是有无消息体部分，GET请求没有消息体，当解析完空行之后，便完成了报文的解析。</p>
<p>但后续的登录和注册功能，为了避免将用户名和密码直接暴露在URL中，我们在项目中改用了POST请求，将用户名和密码添加在报文中作为消息体进行了封装。</p>
<p>为此，我们需要在解析报文的部分添加解析消息体的模块。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>((m_check_state==CHECK_STATE_CONTENT &amp;&amp; line_status==LINE_OK)||((line_status=<span class="built_in">parse_line</span>())==LINE_OK))</span><br></pre></td></tr></table></figure>
<p>那么，这里的判断条件为什么要写成这样呢？</p>
<p>在GET请求报文中，每一行都是\r\n作为结束，所以对报文进行拆解时，仅用从状态机的状态line_status&#x3D;parse_line())&#x3D;&#x3D;LINE_OK语句即可。</p>
<p>但，在POST请求报文中，消息体的末尾没有任何字符，所以不能使用从状态机的状态，这里转而使用主状态机的状态作为循环入口条件。</p>
<p>那后面的&amp;&amp; line_status&#x3D;&#x3D;LINE_OK又是为什么？</p>
<p>解析完消息体后，报文的完整解析就完成了，但此时主状态机的状态还是CHECK_STATE_CONTENT，也就是说，符合循环入口条件，还会再次进入循环，这并不是我们所希望的。</p>
<p>为此，增加了该语句，并在完成消息体解析后，将line_status变量更改为LINE_OPEN，此时可以跳出循环，完成报文解析任务。</p>
<ul>
<li>CHECK_STATE_CONTENT<ul>
<li>仅用于解析POST请求，调用parse_content函数解析消息体</li>
<li>用于保存post请求消息体，为后面的登录和注册做准备</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断http请求是否被完整读入</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//判断buffer中是否读取了消息体</span></span><br><span class="line">    <span class="keyword">if</span>(m_read_idx&gt;=(m_content_length+m_checked_idx))&#123;</span><br><span class="line"></span><br><span class="line">        text[m_content_length]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//POST请求中最后为输入的用户名和密码</span></span><br><span class="line">		m_string = text;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>状态机和HTTP报文解析是项目中最繁琐的部分，这次我们一举解决掉它，希望对各位小伙伴在理解项目的过程中有所帮助。</p>
<p>下篇，我们将对HTTP报文响应进行详解。</p>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 07 定时器处理非活动连接（上）</title>
    <url>/posts/6c8606a9/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>非活跃</code>，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。</p>
<p><code>定时事件</code>，是指固定一段时间之后触发某段代码，由该段代码执行一个处理事件，如定期检测非活跃连接。</p>
<p><code>定时器</code>，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。</p>
<p><code>定时器容器</code>，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。</p>
<h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>本项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。</p>
<p><code>Linux</code>下提供了三种定时的方法:</p>
<ul>
<li>socket选项SO_RECVTIMEO和SO_SNDTIMEO</li>
<li>SIGARAM信号</li>
<li>I&#x2F;O复用系统调用的超时参数</li>
</ul>
<p>三种方法没有一劳永逸的应用场景，也没有绝对的优劣。由于项目中使用的是<code>SIGARAM</code>信号，这里仅对其进行介绍，另外两种方法可以查阅游双的<code>Linux高性能服务器编程 第11章 定时器</code>。</p>
<p>具体的，利用<code>alarm</code>函数周期性地触发<code>SIGARAM</code>信号,该信号的信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。</p>
<p>从上面的简要描述中，可以看出定时器处理非活动连接模块，主要分为两部分，其一为定时方法与信号通知流程，其二为定时器及其容器设计与定时任务的处理。</p>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>本篇将介绍定时方法与信号通知流程，具体的涉及到基础API、信号通知流程和代码实现。</p>
<p><strong>基础API</strong>，描述<code>sigaction</code>结构体、<code>sigaction</code>函数、<code>sigfillset</code>函数、<code>SIGALRM</code>信号、<code>SIGTERM</code>信号、alarm<code>函数、</code>socketpair<code>函数、</code>send&#96;函数。</p>
<p><strong>信号通知流程</strong>，介绍统一事件源和信号处理机制。</p>
<p><strong>代码实现</strong>，结合代码对信号处理函数的设计与使用进行详解。</p>
<h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><p>为了更好的源码阅读体验，这里提前对代码中使用的一些API进行简要介绍，更丰富的用法可以自行查阅资料。</p>
<h4 id="sigaction结构体"><a href="#sigaction结构体" class="headerlink" title="sigaction结构体"></a><strong><span  style="color: #00ACC1; ">sigaction结构体</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    <span class="built_in">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sa_handler是一个函数指针，是一个信号处理函数</li>
<li>sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息</li>
<li>sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号</li>
<li>sa_flags成员用于指定信号处理的行为<ul>
<li>SA_RESTART，使被信号打断的系统调用自动重新发起。</li>
<li>SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。</li>
<li>SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。</li>
<li>SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</li>
<li>SA_RESETHAND，信号处理之后重新设置为默认的处理方式。</li>
<li>SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。</li>
</ul>
</li>
<li>sa_restorer一般不使用</li>
</ul>
<h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a><strong><span  style="color: #00ACC1; ">sigaction函数</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>signum表示操作的信号。</li>
<li>act表示对信号设置新的处理方式。</li>
<li>oldact表示信号原来的处理方式。</li>
<li>返回值，0 表示成功，-1 表示有错误发生。</li>
</ul>
<h4 id="sigfillset函数"><a href="#sigfillset函数" class="headerlink" title="sigfillset函数"></a><strong><span  style="color: #00ACC1; ">sigfillset函数</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用来将参数set信号集初始化，然后把所有的信号加入到此信号集里。</p>
<h4 id="SIGALRM、SIGTERM信号"><a href="#SIGALRM、SIGTERM信号" class="headerlink" title="SIGALRM、SIGTERM信号"></a><strong><span  style="color: #00ACC1; ">SIGALRM、SIGTERM信号</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGALRM  14	 <span class="comment">//由alarm系统调用产生timer时钟信号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGTERM  15 	<span class="comment">//终端发送的终止信号</span></span></span><br></pre></td></tr></table></figure>

<h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a><strong><span  style="color: #00ACC1; ">alarm函数</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>设置信号传送闹钟，即用来设置信号SIGALRM在经过参数seconds秒数后发送给目前的进程。如果未设置信号SIGALRM的处理函数，那么alarm()默认处理终止进程.</p>
<h4 id="socketpair函数"><a href="#socketpair函数" class="headerlink" title="socketpair函数"></a><strong><span  style="color: #00ACC1; ">socketpair函数</span></strong></h4><p>在linux下，使用socketpair函数能够创建一对套接字进行通信，项目中使用管道通信。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>domain表示协议族，PF_UNIX或者AF_UNIX</li>
<li>type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP</li>
<li>protocol表示类型，只能为0</li>
<li>sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作</li>
<li>返回结果， 0为创建成功，-1为创建失败</li>
</ul>
<h4 id="send函数"><a href="#send函数" class="headerlink" title="send函数"></a><strong><span  style="color: #00ACC1; ">send函数</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当套接字发送缓冲区变满时，send通常会阻塞，除非套接字在事先设置为非阻塞的模式，那样他不会阻塞，而是返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。</p>
<h3 id="信号通知流程"><a href="#信号通知流程" class="headerlink" title="信号通知流程"></a>信号通知流程</h3><p>Linux下的信号采用的异步处理机制，具体的，当进程收到信号时，操作系统会中断进程当前的正常流程，转而进入响应的信号处理函数执行操作，完成后再返回中断的地方继续执行。</p>
<p>信号处理函数和程序主循环是两条不同的执行路线，信号处理期间系统不会再次触发它。所以，为确保该信号不被屏蔽太久，信号处理函数需要尽可能快地执行完毕。</p>
<p>一般的信号处理函数需要处理该信号对应的逻辑，当该逻辑比较复杂时，信号处理函数执行时间过长，会导致信号屏蔽太久。</p>
<p>这里的解决方案是，信号处理函数仅仅发送信号通知主循环，将信号对应的逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。</p>
<h4 id="统一事件源"><a href="#统一事件源" class="headerlink" title="统一事件源"></a><strong><span  style="color: #00ACC1; ">统一事件源</span></strong></h4><p>统一事件源，是指将信号事件与其他事件一样被处理。</p>
<p>具体的，信号处理函数使用管道将信号传递给主循环：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用I&#x2F;O复用系统调用来监听管道读端的可读事件。</p>
<h4 id="信号处理机制"><a href="#信号处理机制" class="headerlink" title="信号处理机制"></a><strong><span  style="color: #00ACC1; ">信号处理机制</span></strong></h4><p>每个进程之中，都有存着一个表，里面存着每种信号所代表的含义，内核通过设置表项中每一个位来标识对应的信号类型。</p>
<div align=center><img src="http://ww1.sinaimg.cn/large/005TJ2c7ly1gdupgtksmbj30nx08ggma.jpg" height="304"/> </div>
* 信号的接收
    * 接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。

<ul>
<li><p>信号的检测</p>
<ul>
<li>进程陷入内核态后，有两种场景会对信号进行检测：<ul>
<li>进程从内核态返回到用户态前进行信号检测</li>
<li>进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</li>
</ul>
</li>
<li>当发现有新信号时，便会进入下一步，信号的处理。</li>
</ul>
</li>
<li><p>信号的处理</p>
<ul>
<li>( <strong>内核</strong> )信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</li>
<li>( <strong>用户</strong> )接下来进程返回到用户态中，执行相应的信号处理函数。</li>
<li>( <strong>内核</strong> )信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。</li>
<li>( <strong>用户</strong> )如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</li>
</ul>
</li>
</ul>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a><strong><span  style="color: #00ACC1; ">代码逻辑</span></strong></h4><ul>
<li>创建管道，其中管道写端写入信号值，管道读端通过I&#x2F;O复用系统监测读事件</li>
<li>设置信号处理函数SIGALRM（时间到了触发）和SIGTERM（kill会触发，Ctrl+C）<ul>
<li>通过struct sigaction结构体和sigaction函数注册信号捕捉函数 </li>
<li>在结构体的回调函数中设置事件，从管道写端写入信号的名字</li>
</ul>
</li>
<li>利用I&#x2F;O复用系统监听管道读端文件描述符的可读事件</li>
<li>信息值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码</li>
</ul>
<h4 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a><strong><span  style="color: #00ACC1; ">信号处理函数</span></strong></h4><p>自定义信号处理函数，创建sigaction结构体变量，设置信号函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//为保证函数的可重入性，保留原来的errno</span></span><br><span class="line">	<span class="comment">//可重入性表示中断后再次进入该函数，环境变量与之前相同，不会丢失数据</span></span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将信号值从管道写端写入，传输字符类型，而非整型</span></span><br><span class="line">    <span class="built_in">send</span>(pipefd[<span class="number">1</span>], (<span class="type">char</span> *)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将原来的errno赋值为当前的errno</span></span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号处理函数中仅仅通过管道发送信号值，不处理信号对应的逻辑，缩短异步执行时间，减少对主程序的影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置信号函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addsig</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span>(handler)(<span class="type">int</span>), <span class="type">bool</span> restart = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建sigaction结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//信号处理函数中仅仅发送信号值，不做对应逻辑处理</span></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (restart)</span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">	<span class="comment">//将所有信号添加到信号集中</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//执行sigaction函数</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>项目中设置信号函数，仅关注SIGTERM和SIGALRM两个信号。</p>
<h4 id="管道通知"><a href="#管道通知" class="headerlink" title="管道通知"></a><strong><span  style="color: #00ACC1; ">管道通知</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建管道套接字</span></span><br><span class="line">ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line"><span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置管道写端为非阻塞，为什么写端要非阻塞？</span></span><br><span class="line"><span class="built_in">setnonblocking</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置管道读端为ET非阻塞</span></span><br><span class="line"><span class="built_in">addfd</span>(epollfd, pipefd[<span class="number">0</span>], <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递给主循环的信号值，这里只关注SIGALRM和SIGTERM</span></span><br><span class="line"><span class="built_in">addsig</span>(SIGALRM, sig_handler, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">addsig</span>(SIGTERM, sig_handler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环条件</span></span><br><span class="line"><span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时标志</span></span><br><span class="line"><span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每隔TIMESLOT时间触发SIGALRM信号</span></span><br><span class="line"><span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//监测发生事件的文件描述符</span></span><br><span class="line">	<span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//轮询文件描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//管道读端对应文件描述符发生读事件</span></span><br><span class="line">        <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sig;</span><br><span class="line">            <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//从管道读端读出信号值，成功返回字节数，失败返回-1</span></span><br><span class="line">			<span class="comment">//正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符</span></span><br><span class="line">            ret = <span class="built_in">recv</span>(pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// handle the error</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//处理信号值对应的逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">					<span class="comment">//这里面明明是字符</span></span><br><span class="line">                    <span class="keyword">switch</span> (signals[i])</span><br><span class="line">                    &#123;</span><br><span class="line">					<span class="comment">//这里是整型</span></span><br><span class="line">                    <span class="keyword">case</span> SIGALRM:</span><br><span class="line">                    &#123;</span><br><span class="line">                        timeout = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                    &#123;</span><br><span class="line">                        stop_server = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><span  style="color: #00ACC1; ">为什么管道写端要非阻塞？</span></strong></p>
<p>send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。</p>
<p><strong><span  style="color: #00ACC1; ">没有对非阻塞返回值处理，如果阻塞是不是意味着这一次定时事件失效了？</span></strong></p>
<p>是的，但定时事件并不是非必须立即处理的事件，可以允许这样的情况发生。</p>
<p><strong><span  style="color: #00ACC1; ">管道传递的是什么类型？switch-case的变量冲突？</span></strong></p>
<p>信号本身是整型数值，管道中传递的是ASCII码表中整型数值对应的字符。switch的变量一般为字符或整型，当为字符时，case中可以是字符，也可以是字符对应的ASCII码。</p>
<p>如果本文对你有帮助，<strong>阅读原文star一下TinyWebServer项目</strong>，我们需要你的星星。</p>
<p>完。</p>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 08 定时器处理非活动连接（下）</title>
    <url>/posts/cb70464/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>定时器处理非活动连接模块，主要分为两部分，其一为定时方法与信号通知流程，其二为定时器及其容器设计、定时任务的处理。</p>
<p>本篇对第二部分进行介绍，具体的涉及到定时器设计、容器设计、定时任务处理函数和使用定时器。</p>
<p><code>定时器设计</code>，将连接资源和定时事件等封装起来，具体包括连接资源、超时时间和回调函数，这里的回调函数指向定时事件。</p>
<p><code>定时器容器设计</code>，将多个定时器串联组织起来统一处理，具体包括升序链表设计。</p>
<p><code>定时任务处理函数</code>，该函数封装在容器类中，具体的，函数遍历升序链表容器，根据超时时间，处理对应的定时器。</p>
<p><code>代码分析-使用定时器</code>，通过代码分析，如何在项目中使用定时器。</p>
<h3 id="定时器设计"><a href="#定时器设计" class="headerlink" title="定时器设计"></a>定时器设计</h3><p>项目中将连接资源、定时事件和超时时间封装为定时器类，具体的，</p>
<ul>
<li>连接资源包括客户端套接字地址、文件描述符和定时器</li>
<li>定时事件为回调函数，将其封装起来由用户自定义，这里是删除非活动socket上的注册事件，并关闭</li>
<li>定时器超时时间 &#x3D; 浏览器和服务器连接时刻 + 固定时间(TIMESLOT)，可以看出，定时器使用绝对时间作为超时值，这里alarm设置为5秒，连接超时为15秒。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//连接资源结构体成员需要用到定时器类</span></span><br><span class="line"><span class="comment">//需要前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">util_timer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接资源</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_data</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//客户端socket地址</span></span><br><span class="line">    sockaddr_in address;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//socket文件描述符</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定时器</span></span><br><span class="line">    util_timer* timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">util_timer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">util_timer</span>() : <span class="built_in">prev</span>( <span class="literal">NULL</span> ), <span class="built_in">next</span>( <span class="literal">NULL</span> )&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="type">time_t</span> expire; </span><br><span class="line">	<span class="comment">//回调函数</span></span><br><span class="line">    <span class="built_in">void</span> (*cb_func)( client_data* );</span><br><span class="line">	<span class="comment">//连接资源</span></span><br><span class="line">    client_data* user_data;</span><br><span class="line">	<span class="comment">//前向定时器</span></span><br><span class="line">    util_timer* prev;</span><br><span class="line">	<span class="comment">//后继定时器</span></span><br><span class="line">    util_timer* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定时事件，具体的，从内核事件表删除事件，关闭文件描述符，释放连接资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定时器回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//删除非活动连接在socket上的注册事件</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(user_data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(user_data-&gt;sockfd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//减少连接数</span></span><br><span class="line">    http_conn::m_user_count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器容器设计"><a href="#定时器容器设计" class="headerlink" title="定时器容器设计"></a>定时器容器设计</h3><p>项目中的定时器容器为带头尾结点的升序双向链表，具体的为每个连接创建一个定时器，将其添加到链表中，并按照超时时间升序排列。执行定时任务时，将到期的定时器从链表中删除。</p>
<p>从实现上看，主要涉及双向链表的插入，删除操作，其中添加定时器的事件复杂度是O(n),删除定时器的事件复杂度是O(1)。</p>
<p>升序双向链表主要逻辑如下，具体的，</p>
<ul>
<li>创建头尾节点，其中头尾节点没有意义，仅仅统一方便调整</li>
<li>add_timer函数，将目标定时器添加到链表中，添加时按照升序添加<ul>
<li>若当前链表中只有头尾节点，直接插入</li>
<li>否则，将定时器按升序插入</li>
</ul>
</li>
<li>adjust_timer函数，当定时任务发生变化,调整对应定时器在链表中的位置<ul>
<li>客户端在设定时间内有数据收发,则当前时刻对该定时器重新设定时间，这里只是往后延长超时时间</li>
<li>被调整的目标定时器在尾部，或定时器新的超时值仍然小于下一个定时器的超时，不用调整</li>
<li>否则先将定时器从链表取出，重新插入链表</li>
</ul>
</li>
<li>del_timer函数将超时的定时器从链表中删除<ul>
<li>常规双向链表删除结点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器容器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sort_timer_lst</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sort_timer_lst</span>() : <span class="built_in">head</span>( <span class="literal">NULL</span> ), <span class="built_in">tail</span>( <span class="literal">NULL</span> ) &#123;&#125;</span><br><span class="line">	<span class="comment">//常规销毁链表</span></span><br><span class="line">    ~<span class="built_in">sort_timer_lst</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        util_timer* tmp = head;</span><br><span class="line">        <span class="keyword">while</span>( tmp )</span><br><span class="line">        &#123;</span><br><span class="line">            head = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            tmp = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加定时器，内部调用私有成员add_timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( !head )</span><br><span class="line">        &#123;</span><br><span class="line">            head = tail = timer;</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果新的定时器超时时间小于当前头部结点</span></span><br><span class="line">		<span class="comment">//直接将当前定时器结点作为头部结点</span></span><br><span class="line">        <span class="keyword">if</span>( timer-&gt;expire &lt; head-&gt;expire )</span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;next = head;</span><br><span class="line">            head-&gt;prev = timer;</span><br><span class="line">            head = timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//否则调用私有成员，调整内部结点</span></span><br><span class="line">        <span class="built_in">add_timer</span>( timer, head );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调整定时器，任务发生变化时，调整定时器在链表中的位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        util_timer* tmp = timer-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//被调整的定时器在链表尾部</span></span><br><span class="line">		<span class="comment">//定时器超时值仍然小于下一个定时器超时值，不调整</span></span><br><span class="line">        <span class="keyword">if</span>( !tmp || ( timer-&gt;expire &lt; tmp-&gt;expire ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//被调整定时器是链表头结点，将定时器取出，重新插入</span></span><br><span class="line">        <span class="keyword">if</span>( timer == head )</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">add_timer</span>( timer, head );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//被调整定时器在内部，将定时器取出，重新插入</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">            timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">            <span class="built_in">add_timer</span>( timer, timer-&gt;next );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除定时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( !timer )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//链表中只有一个定时器，需要删除该定时器</span></span><br><span class="line">        <span class="keyword">if</span>( ( timer == head ) &amp;&amp; ( timer == tail ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            head = <span class="literal">NULL</span>;</span><br><span class="line">            tail = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//被删除的定时器为头结点</span></span><br><span class="line">        <span class="keyword">if</span>( timer == head )</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//被删除的定时器为尾结点</span></span><br><span class="line">        <span class="keyword">if</span>( timer == tail )</span><br><span class="line">        &#123;</span><br><span class="line">            tail = tail-&gt;prev;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//被删除的定时器在链表内部，常规链表结点删除</span></span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//私有成员，被公有成员add_timer和adjust_time调用</span></span><br><span class="line">	<span class="comment">//主要用于调整链表内部结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">( util_timer* timer, util_timer* lst_head )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        util_timer* prev = lst_head;</span><br><span class="line">        util_timer* tmp = prev-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历当前结点之后的链表，按照超时时间找到目标定时器对应的位置，常规双向链表插入操作</span></span><br><span class="line">        <span class="keyword">while</span>( tmp )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( timer-&gt;expire &lt; tmp-&gt;expire )</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = timer;</span><br><span class="line">                timer-&gt;next = tmp;</span><br><span class="line">                tmp-&gt;prev = timer;</span><br><span class="line">                timer-&gt;prev = prev;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = tmp;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历完发现，目标定时器需要放到尾结点处</span></span><br><span class="line">        <span class="keyword">if</span>( !tmp )</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            tail = timer;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//头尾结点</span></span><br><span class="line">    util_timer* head;</span><br><span class="line">    util_timer* tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="定时任务处理函数"><a href="#定时任务处理函数" class="headerlink" title="定时任务处理函数"></a>定时任务处理函数</h3><p>使用统一事件源，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</p>
<p>具体的逻辑如下，</p>
<ul>
<li>遍历定时器升序链表容器，从头结点开始依次处理每个定时器，直到遇到尚未到期的定时器</li>
<li>若当前时间小于定时器超时时间，跳出循环，即未找到到期的定时器</li>
<li>若当前时间大于定时器超时时间，即找到了到期的定时器，执行回调函数，然后将它从链表中删除，然后继续遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时任务处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !head )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line">    util_timer* tmp = head;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历定时器链表</span></span><br><span class="line">    <span class="keyword">while</span>( tmp )</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//链表容器为升序排列</span></span><br><span class="line">		<span class="comment">//当前时间小于定时器的超时时间，后面的定时器也没有到期</span></span><br><span class="line">        <span class="keyword">if</span>( cur &lt; tmp-&gt;expire )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当前定时器到期，则调用回调函数，执行定时事件</span></span><br><span class="line">        tmp-&gt;<span class="built_in">cb_func</span>( tmp-&gt;user_data );</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将处理后的定时器从链表容器中删除，并重置头结点</span></span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>( head )</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码分析-如何使用定时器"><a href="#代码分析-如何使用定时器" class="headerlink" title="代码分析-如何使用定时器"></a>代码分析-如何使用定时器</h3><p>服务器首先创建定时器容器链表，然后用统一事件源将异常事件，读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器。</p>
<p>具体的，</p>
<ul>
<li>浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到链表上</li>
<li>处理异常事件时，执行定时事件，服务器关闭连接，从链表上移除对应定时器</li>
<li>处理定时信号时，将定时标志设置为true</li>
<li>处理读事件时，若某连接上发生读事件，将对应定时器向后移动，否则，执行定时事件</li>
<li>处理写事件时，若服务器通过某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建定时器容器链表</span></span><br><span class="line"><span class="type">static</span> sort_timer_lst timer_lst;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接资源数组</span></span><br><span class="line">client_data *users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时默认为False</span></span><br><span class="line"><span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//alarm定时触发SIGALRM信号</span></span><br><span class="line"><span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理新到的客户连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//初始化客户端连接地址</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//该连接分配的文件描述符</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//初始化该连接对应的连接资源</span></span><br><span class="line">            users_timer[connfd].address = client_address;</span><br><span class="line">            users_timer[connfd].sockfd = connfd;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建定时器临时变量</span></span><br><span class="line">            util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">			<span class="comment">//设置定时器对应的连接资源</span></span><br><span class="line">            timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line">			<span class="comment">//设置回调函数</span></span><br><span class="line">            timer-&gt;cb_func = cb_func;</span><br><span class="line"></span><br><span class="line">            <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">			<span class="comment">//设置绝对超时时间</span></span><br><span class="line">            timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">			<span class="comment">//创建该连接对应的定时器，初始化为前述临时变量</span></span><br><span class="line">            users_timer[connfd].timer = timer;</span><br><span class="line">			<span class="comment">//将该定时器添加到链表中</span></span><br><span class="line">            timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//处理异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">            <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">			</span><br><span class="line">            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理定时器信号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//接收到SIGALRM信号，timeout设置为True</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//创建定时器临时变量，将该连接对应的定时器取出来</span></span><br><span class="line">            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line">                <span class="comment">//对其在链表上的位置进行调整</span></span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">       &#123;</span><br><span class="line">           util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">           <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line">                <span class="comment">//并对新的定时器在链表上的位置进行调整</span></span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//处理定时器为非必须事件，收到信号并不是立马处理</span></span><br><span class="line">	<span class="comment">//完成读写事件后，再进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">timer_handler</span>();</span><br><span class="line">        timeout = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><span  style="color: #00ACC1; ">有小伙伴问，连接资源中的address是不是有点鸡肋？</span></strong></p>
<p>确实如此，项目中虽然对该变量赋值，但并没有用到。类似的，可以对比HTTP类中address属性，只在日志输出中用到。</p>
<p>但不能说这个变量没有用，因为我们可以找到客户端连接的ip地址，用它来做一些业务，比如通过ip来判断是否异地登录等等。</p>
<p>如果本文对你有帮助，<code>阅读原文</code>star一下服务器项目，我们需要你的星星^_^.</p>
<p>完。</p>
<div align=center><img src="http://ww1.sinaimg.cn/large/005TJ2c7ly1gdzzwg1wklj30p00dwtaf.jpg" height="300"/> </div>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 09 日志系统（上）</title>
    <url>/posts/8347b75d/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>日志</code>，由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。</p>
<p><code>同步日志</code>，日志写入函数与工作线程串行执行，由于涉及到I&#x2F;O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。</p>
<p><code>生产者-消费者模型</code>，并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。生产者和消费者是互斥关系，两者对缓冲区访问互斥，同时生产者和消费者又是一个相互协作与同步的关系，只有生产者生产之后，消费者才能消费。</p>
<p><code>阻塞队列</code>，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。</p>
<p><code>异步日志</code>，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。</p>
<p><code>单例模式</code>，最简单也是被问到最多的设计模式之一，保证一个类只创建一个实例，同时提供全局访问的方法。</p>
<h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>本项目中，使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。</p>
<p>其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。</p>
<p>日志系统大致可以分成两部分，其一是单例模式与阻塞队列的定义，其二是日志类的定义与使用。</p>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>本篇将介绍单例模式与阻塞队列的定义，具体的涉及到单例模式、生产者-消费者模型，阻塞队列的代码实现。</p>
<p><strong>单例模式</strong>，描述懒汉与饿汉两种单例模式，并结合线程安全进行讨论。</p>
<p><strong>生产者-消费者模型</strong>，描述条件变量，基于该同步机制实现简单的生产者-消费者模型。</p>
<p><strong>代码实现</strong>，结合代码对阻塞队列的设计进行详解。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ2xlZS9wLzU3MzgxNjQuaHRtbA==">单例模式<i class="fa fa-external-link-alt"></i></span></h3><p>单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
<p>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p>
<p>单例模式有两种实现方法，分别是懒汉和饿汉模式。顾名思义，懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；饿汉模式，即迫不及待，在程序运行时立即初始化。</p>
<h4 id="经典的线程安全懒汉模式"><a href="#经典的线程安全懒汉模式" class="headerlink" title="经典的线程安全懒汉模式"></a><strong><span  style="color: #00ACC1; ">经典的线程安全懒汉模式</span></strong></h4><p>单例模式的实现思路如前述所示，其中，经典的线程安全懒汉模式，使用双检测锁模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//私有静态指针变量指向唯一实例</span></span><br><span class="line">	<span class="type">static</span> single *p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态锁，是由于静态函数只能访问静态成员</span></span><br><span class="line">	<span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//私有化构造函数</span></span><br><span class="line">	<span class="built_in">single</span>()&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//公有静态方法获取实例</span></span><br><span class="line">	<span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> single::lock;</span><br><span class="line"></span><br><span class="line">single* single::p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">			p = <span class="keyword">new</span> single;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>为什么要用双锁，一层锁不行吗？</code></p>
<p>如果仅用一层锁，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层锁可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL &#x3D;&#x3D; p的情况，直接返回已创建好的实例。</p>
<h4 id="局部静态变量之线程安全懒汉模式"><a href="#局部静态变量之线程安全懒汉模式" class="headerlink" title="局部静态变量之线程安全懒汉模式"></a><strong><span  style="color: #00ACC1; ">局部静态变量之线程安全懒汉模式</span></strong></h4><p>前面的双检测锁模式，写起来不太优雅，《Effective C++》（Item 04）中的提出另一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line">	~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> single obj;</span><br><span class="line">	<span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>这时候有人说了，这种方法不加锁会不会造成线程安全问题？</code></p>
<p>其实，C++0X以后，要求编译器保证内部静态变量的线程安全性，故C++0x之后该实现是线程安全的，C++0x之前仍需加锁，其中C++0x是C++11标准成为正式标准之前的草案临时名字。</p>
<p>所以，如果使用C++11之前的标准，还是需要加锁，这里同样给出加锁的版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">	<span class="built_in">single</span>()&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">pthread_mutex_t</span> single::lock;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">	<span class="type">static</span> single obj;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">	<span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a><strong><span  style="color: #00ACC1; ">饿汉模式</span></strong></h4><p>饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> single* p;</span><br><span class="line">	<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line">	~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">single* single::p = <span class="keyword">new</span> <span class="built_in">single</span>();</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	single *p1 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	single *p2 = single::<span class="built_in">getinstance</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1 == p2)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p>
<h3 id="条件变量与生产者-消费者模型"><a href="#条件变量与生产者-消费者模型" class="headerlink" title="条件变量与生产者-消费者模型"></a>条件变量与生产者-消费者模型</h3><h4 id="条件变量API与陷阱"><a href="#条件变量API与陷阱" class="headerlink" title="条件变量API与陷阱"></a><strong><span  style="color: #00ACC1; ">条件变量API与陷阱</span></strong></h4><p>条件变量提供了一种线程间的通知机制，当某个共享数据达到某个值时,唤醒等待这个共享数据的线程。</p>
<h5 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h5><ul>
<li>pthread_cond_init函数，用于初始化条件变量</li>
<li>pthread_cond_destory函数，销毁条件变量</li>
<li>pthread_cond_broadcast函数，以广播的方式唤醒<strong>所有</strong>等待目标条件变量的线程</li>
<li>pthread_cond_wait函数，用于等待目标条件变量。该函数调用时需要传入 <strong>mutex参数(加锁的互斥锁)</strong> ，函数执行时，先把调用线程放入条件变量的请求队列，然后将互斥锁mutex解锁，当函数成功返回为0时，表示重新抢到了互斥锁，互斥锁会再次被锁上， <strong>也就是说函数内部会有一次解锁和加锁操作</strong>.</li>
</ul>
<p>使用pthread_cond_wait方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pthread _mutex_lock(&amp;mutex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(线程执行的条件是否成立)&#123;</span><br><span class="line">	<span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>pthread_cond_wait执行后的内部操作分为以下几步：</p>
<ul>
<li><p>将线程放在条件变量的请求队列后，内部解锁</p>
</li>
<li><p>等待pthread_cond_signal或者pthread_cond_broadcast信号唤醒，唤醒后去竞争锁</p>
</li>
<li><p>若竞争到互斥锁，内部再次加锁</p>
</li>
</ul>
<h5 id="陷阱一"><a href="#陷阱一" class="headerlink" title="陷阱一"></a>陷阱一</h5><p><code>使用前要加锁，为什么要加锁？</code></p>
<p>多线程访问，为了避免资源竞争，所以要加锁，使得每个线程互斥的访问公有资源。</p>
<p><code>pthread_cond_wait内部为什么要解锁？</code></p>
<p>如果while或者if判断的时候，满足执行条件，线程便会调用pthread_cond_wait阻塞自己，此时它还在持有锁，如果他不解锁，那么其他线程将会无法访问公有资源。</p>
<p>具体到pthread_cond_wait的内部实现，当pthread_cond_wait被调用线程阻塞的时候，pthread_cond_wait会自动释放互斥锁。</p>
<p><code>为什么要把调用线程放入条件变量的请求队列后再解锁？</code></p>
<p>线程是并发执行的，如果在把调用线程A放在等待队列之前，就释放了互斥锁，这就意味着其他线程比如线程B可以获得互斥锁去访问公有资源，这时候线程A所等待的条件改变了，但是它没有被放在等待队列上，导致A忽略了等待条件被满足的信号。</p>
<p>倘若在线程A调用pthread_cond_wait开始，到把A放在等待队列的过程中，都持有互斥锁，其他线程无法得到互斥锁，就不能改变公有资源。</p>
<p><code>为什么最后还要加锁？</code></p>
<p>将线程放在条件变量的请求队列后，将其解锁，此时等待。</p>
<h5 id="陷阱二"><a href="#陷阱二" class="headerlink" title="陷阱二"></a>陷阱二</h5><p><code>为什么判断线程执行的条件用while而不是if？</code></p>
<p>一般来说，在多线程资源竞争的时候，在一个使用资源的线程里面（消费者）判断资源是否可用，不可用，便调用pthread_cond_wait，在另一个线程里面（生产者）如果判断资源可用的话，则调用pthread_cond_signal发送一个资源可用信号。</p>
<p>在wait成功之后，资源就一定可以被使用么？答案是否定的，如果同时有两个或者两个以上的线程正在等待此资源，wait返回后，资源可能已经被使用了。</p>
<p>再具体点，有可能多个线程都在等待这个资源可用的信号，信号发出后只有一个资源可用，但是有A，B两个线程都在等待，B比较速度快，获得互斥锁，然后加锁，消耗资源，然后解锁，之后A获得互斥锁，但A回去发现资源已经被使用了，它便有两个选择，一个是去访问不存在的资源，另一个就是继续等待，那么继续等待下去的条件就是使用while，要不然使用if的话pthread_cond_wait返回后，就会顺序执行下去。</p>
<p>所以，在这种情况下，应该使用while而不是if:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(resource == FALSE)</span><br><span class="line">	<span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br></pre></td></tr></table></figure>

<p>如果之后一个消费者，那么使用if是可以的。</p>
<h4 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a><strong><span  style="color: #00ACC1; ">生产者-消费者模型</span></strong></h4><p>这里摘抄《Unix 环境高级编程》中第11章线程关于pthread_cond_wait的介绍中有一个生产者-消费者的例子P311，其中，process_msg相当于消费者，enqueue_msg相当于生产者，struct msg* workq作为缓冲队列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">msg</span> *m_next;</span><br><span class="line">  <span class="comment">/* value...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span>* workq;</span><br><span class="line"><span class="type">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">process_msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">msg</span>* mp;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;qlock);</span><br><span class="line">	<span class="comment">//这里需要用while，而不是if</span></span><br><span class="line">    <span class="keyword">while</span> (workq == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">pthread_cond_wait</span>(&amp;qread, &amp;qlock);</span><br><span class="line">    &#125;</span><br><span class="line">    mq = workq;</span><br><span class="line">    workq = mp-&gt;m_next;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;qlock);</span><br><span class="line">    <span class="comment">/* now process the message mp */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">enqueue_msg</span><span class="params">(<span class="keyword">struct</span> msg* mp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;qlock);</span><br><span class="line">    mp-&gt;m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;qlock);</span><br><span class="line">    <span class="comment">/** 此时另外一个线程在signal之前，执行了process_msg，刚好把mp元素拿走*/</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;qready);</span><br><span class="line">    <span class="comment">/** 此时执行signal, 在pthread_cond_wait等待的线程被唤醒，</span></span><br><span class="line"><span class="comment">        但是mp元素已经被另外一个线程拿走，所以，workq还是NULL ,因此需要继续等待*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阻塞队列代码分析"><a href="#阻塞队列代码分析" class="headerlink" title="阻塞队列代码分析"></a>阻塞队列代码分析</h3><p>阻塞队列类中封装了生产者-消费者模型，其中push成员是生产者，pop成员是消费者。</p>
<p>阻塞队列中，使用了循环数组实现了队列，作为两者共享缓冲区，当然了，队列也可以使用STL中的queue。</p>
<h4 id="自定义队列"><a href="#自定义队列" class="headerlink" title="自定义队列"></a><strong><span  style="color: #00ACC1; ">自定义队列</span></strong></h4><p>当队列为空时，从队列中获取元素的线程将会被挂起；当队列是满时，往队列里添加元素的线程将会挂起。</p>
<p>阻塞队列类中，有些代码比较简单，这里仅对push和pop成员进行详解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">block_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化私有成员</span></span><br><span class="line">	<span class="built_in">block_queue</span>(<span class="type">int</span> max_size = <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//构造函数创建循环数组</span></span><br><span class="line">        m_max_size = max_size;</span><br><span class="line">        m_array = <span class="keyword">new</span> T[max_size];</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建互斥锁和条件变量</span></span><br><span class="line">        m_mutex = <span class="keyword">new</span> <span class="type">pthread_mutex_t</span>;</span><br><span class="line">        m_cond = <span class="keyword">new</span> <span class="type">pthread_cond_t</span>;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(m_mutex, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(m_cond, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往队列添加元素，需要将所有使用队列的线程先唤醒</span></span><br><span class="line">    <span class="comment">//当有元素push进队列，相当于生产者生产了一个元素</span></span><br><span class="line">    <span class="comment">//若当前没有线程等待条件变量,则唤醒无意义</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(m_mutex);</span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_broadcast</span>(m_cond);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(m_mutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将新增数据放在循环数组的对应位置</span></span><br><span class="line">        m_back = (m_back + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        m_array[m_back] = item;</span><br><span class="line">        m_size++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_cond_broadcast</span>(m_cond);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(m_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pop时，如果当前队列没有元素,将会等待条件变量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(m_mutex);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//多个消费者的时候，这里要是用while而不是if</span></span><br><span class="line">        <span class="keyword">while</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//当重新抢到互斥锁，pthread_cond_wait返回为0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">pthread_cond_wait</span>(m_cond, m_mutex))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(m_mutex);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//取出队列首的元素，这里需要理解一下，使用循环数组模拟的队列	</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(m_mutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加了超时处理，在项目中没有使用到</span></span><br><span class="line">	<span class="comment">//在pthread_cond_wait基础上增加了等待的时间，只指定时间内能抢到互斥锁即可</span></span><br><span class="line">	<span class="comment">//其他逻辑不变</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="type">int</span> ms_timeout)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span> t = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(m_mutex);</span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t.tv_sec = now.tv_sec + ms_timeout / <span class="number">1000</span>;</span><br><span class="line">            t.tv_nsec = (ms_timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">pthread_cond_timedwait</span>(m_cond, m_mutex, &amp;t))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(m_mutex);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(m_mutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(m_mutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ2xlZS9wLzU3MzgxNjQuaHRtbA==">https://www.cnblogs.com/songlee/p/5738164.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3eTIwOTAvYXJ0aWNsZS9kZXRhaWxzLzEzNTEyMjU5">https://blog.csdn.net/ywy2090/article/details/13512259<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjA3NzU0NDgtaWQtNTc3NjU1NS5odG1s">http://blog.chinaunix.net/uid-20775448-id-5776555.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9iMTYyOTZlOWFjODU=">https://www.jianshu.com/p/b16296e9ac85<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 10 日志系统（下）</title>
    <url>/posts/21141ced/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>日志系统分为两部分，其一是单例模式与阻塞队列的定义，其二是日志类的定义与使用。</p>
<p>本篇将介绍日志类的定义与使用，具体的涉及到基础API，流程图与日志类定义，功能实现。</p>
<p><strong>基础API</strong>，描述fputs，可变参数宏__VA_ARGS__，fflush</p>
<p><strong>流程图与日志类定义</strong>，描述日志系统整体运行流程，介绍日志类的具体定义</p>
<p><strong>功能实现</strong>，结合代码分析同步、异步写文件逻辑，分析超行、按天分文件和日志分级的具体实现</p>
<h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><p>为了更好的源码阅读体验，这里对一些API用法进行介绍。</p>
<h4 id="fputs"><a href="#fputs" class="headerlink" title="fputs"></a><strong><span  style="color: #00ACC1; ">fputs</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>str，一个数组，包含了要写入的以空字符终止的字符序列。</li>
<li>stream，指向FILE对象的指针，该FILE对象标识了要被写入字符串的流。</li>
</ul>
<h4 id="可变参数宏-VA-ARGS"><a href="#可变参数宏-VA-ARGS" class="headerlink" title="可变参数宏__VA_ARGS__"></a><strong><span  style="color: #00ACC1; ">可变参数宏__VA_ARGS__</span></strong></h4><p>__VA_ARGS__是一个可变参数的宏，定义时宏定义中参数列表的最后一个参数为省略号，在实际使用时会发现有时会加##，有时又不加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//最简单的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> my_print1(...)  printf(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//搭配va_list的format使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> my_print2(format, ...) printf(format, __VA_ARGS__)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> my_print3(format, ...) printf(format, ##__VA_ARGS__)</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">\_\_VA\_ARGS\_\_宏前面加上##的作用在于，当可变参数的个数为<span class="number">0</span>时，这里printf参数列表中的的##会把前面多余的<span class="string">&quot;,&quot;</span>去掉，否则会编译出错，建议使用后面这种，使得程序更加健壮。</span><br><span class="line"></span><br><span class="line">#### **&lt;span  style=<span class="string">&quot;color: #00ACC1; &quot;</span>&gt;fflush&lt;/span&gt;**</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="built_in">fflush</span>(FILE *stream);</span><br></pre></td></tr></table></figure>
<p>fflush()会强迫将缓冲区内的数据写回参数stream 指定的文件中，如果参数stream 为NULL，fflush()会将所有打开的文件数据更新。</p>
<p>在使用多个输出函数连续进行多次输出时，有可能下一个数据再上一个数据还没输出完毕，还在输出缓冲区中时，下一个printf就把另一个数据加入输出缓冲区，结果冲掉了原来的数据，出现输出错误。 </p>
<p>在prinf()后加上fflush(stdout); 强制马上输出，可以避免出现上述错误。</p>
<h3 id="流程图与日志类定义"><a href="#流程图与日志类定义" class="headerlink" title="流程图与日志类定义"></a>流程图与日志类定义</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong><span  style="color: #00ACC1; ">流程图</span></strong></h4><ul>
<li>日志文件<ul>
<li>局部变量的懒汉模式获取实例</li>
<li>生成日志文件，并判断同步和异步写入方式</li>
</ul>
</li>
<li>同步<ul>
<li>判断是否分文件</li>
<li>直接格式化输出内容，将信息写入日志文件</li>
</ul>
</li>
<li>异步<ul>
<li>判断是否分文件</li>
<li>格式化输出内容，将内容写入阻塞队列，创建一个写线程，从阻塞队列取出内容写入日志文件</li>
</ul>
</li>
</ul>
<div align=center><img 
src="http://ww1.sinaimg.cn/large/005TJ2c7ly1gefgyft34tj312c0d8ac0.jpg" height="350"/> </div>


<h4 id="日志类定义"><a href="#日志类定义" class="headerlink" title="日志类定义"></a><strong><span  style="color: #00ACC1; ">日志类定义</span></strong></h4><p>通过局部变量的懒汉单例模式创建日志实例，对其进行初始化生成日志文件后，格式化输出内容，并根据不同的写入方式，完成对应逻辑，写入日志文件。</p>
<p>日志类包括但不限于如下方法，</p>
<ul>
<li>公有的实例获取方法</li>
<li>初始化日志文件方法</li>
<li>异步日志写入方法，内部调用私有异步方法</li>
<li>内容格式化方法</li>
<li>刷新缓冲区</li>
<li>…</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//C++11以后,使用局部变量懒汉不用加锁</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Log *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可选择的参数有日志文件、日志缓冲区大小、最大行数以及最长日志条队列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">int</span> log_buf_size = <span class="number">8192</span>, <span class="type">int</span> split_lines = <span class="number">5000000</span>, <span class="type">int</span> max_queue_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异步写日志公有方法，调用私有方法async_write_log</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">flush_log_thread</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">async_write_log</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将输出内容按照标准格式整理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//强制刷新缓冲区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异步写日志方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">async_write_log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string single_log;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从阻塞队列中取出一条日志内容，写入文件</span></span><br><span class="line">        <span class="keyword">while</span> (m_log_queue-&gt;<span class="built_in">pop</span>(single_log))</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">fputs</span>(single_log.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> dir_name[<span class="number">128</span>]; 	<span class="comment">//路径名</span></span><br><span class="line">    <span class="type">char</span> log_name[<span class="number">128</span>]; 	<span class="comment">//log文件名</span></span><br><span class="line">    <span class="type">int</span> m_split_lines;  	<span class="comment">//日志最大行数</span></span><br><span class="line">    <span class="type">int</span> m_log_buf_size; 	<span class="comment">//日志缓冲区大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_count;  	<span class="comment">//日志行数记录</span></span><br><span class="line">    <span class="type">int</span> m_today;        	<span class="comment">//按天分文件,记录当前时间是那一天</span></span><br><span class="line">    FILE *m_fp;         	<span class="comment">//打开log的文件指针</span></span><br><span class="line">    <span class="type">char</span> *m_buf;			<span class="comment">//要输出的内容</span></span><br><span class="line">    block_queue&lt;string&gt; *m_log_queue; <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="type">bool</span> m_is_async;                  <span class="comment">//是否同步标志位</span></span><br><span class="line">    locker m_mutex;			<span class="comment">//同步类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这四个宏定义在其他文件中使用，主要用于不同类型的日志输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) Log::get_instance()-&gt;write_log(0, format, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) Log::get_instance()-&gt;write_log(1, format, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) Log::get_instance()-&gt;write_log(2, format, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) Log::get_instance()-&gt;write_log(3, format, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>日志类中的方法都不会被其他程序直接调用，末尾的四个可变参数宏提供了其他程序的调用方法。</p>
<p>前述方法对日志等级进行分类，包括DEBUG，INFO，WARN和ERROR四种级别的日志。</p>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>init函数实现日志创建、写入方式的判断。</p>
<p>write_log函数完成写入日志文件中的具体内容，主要实现日志分级、分文件、格式化输出内容。</p>
<h4 id="生成日志文件-amp-amp-判断写入方式"><a href="#生成日志文件-amp-amp-判断写入方式" class="headerlink" title="生成日志文件 &amp;&amp; 判断写入方式"></a><strong><span  style="color: #00ACC1; ">生成日志文件 &amp;&amp; 判断写入方式</span></strong></h4><p>通过单例模式获取唯一的日志类，调用init方法，初始化生成日志文件，服务器启动按当前时刻创建日志，前缀为时间，后缀为自定义log文件名，并记录创建日志的时间day和行数count。</p>
<p>写入方式通过初始化时<strong>是否设置队列大小</strong>（表示在队列中可以放几条数据）来判断，若队列大小为0，则为同步，否则为异步。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//异步需要设置阻塞队列的长度，同步不需要设置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Log::init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">int</span> log_buf_size, <span class="type">int</span> split_lines, <span class="type">int</span> max_queue_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果设置了max_queue_size,则设置为异步</span></span><br><span class="line">    <span class="keyword">if</span> (max_queue_size &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//设置写入方式flag</span></span><br><span class="line">        m_is_async = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建并设置阻塞队列长度</span></span><br><span class="line">        m_log_queue = <span class="keyword">new</span> <span class="built_in">block_queue</span>&lt;string&gt;(max_queue_size);</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//flush_log_thread为回调函数,这里表示创建线程异步写日志</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, flush_log_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输出内容的长度</span></span><br><span class="line">    m_log_buf_size = log_buf_size;</span><br><span class="line">    m_buf = <span class="keyword">new</span> <span class="type">char</span>[m_log_buf_size];</span><br><span class="line">    <span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(m_buf));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//日志的最大行数</span></span><br><span class="line">    m_split_lines = split_lines;</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sys_tm = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从后往前找到第一个/的位置</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(file_name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="type">char</span> log_full_name[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于自定义日志名</span></span><br><span class="line">    <span class="comment">//若输入的文件名没有/，则直接将时间+文件名作为日志名</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%d_%02d_%02d_%s&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, file_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将/的位置向后移动一个位置，然后复制到logname中</span></span><br><span class="line">        <span class="comment">//p - file_name + 1是文件所在路径文件夹的长度</span></span><br><span class="line">        <span class="comment">//dirname相当于./</span></span><br><span class="line">        <span class="built_in">strcpy</span>(log_name, p + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(dir_name, file_name, p - file_name + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后面的参数跟format有关</span></span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%s%d_%02d_%02d_%s&quot;</span>, dir_name, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, log_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_today = my_tm.tm_mday;</span><br><span class="line"></span><br><span class="line">    m_fp = <span class="built_in">fopen</span>(log_full_name, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="日志分级与分文件"><a href="#日志分级与分文件" class="headerlink" title="日志分级与分文件"></a><strong><span  style="color: #00ACC1; ">日志分级与分文件</span></strong></h4><p>日志分级的实现大同小异，一般的会提供五种级别，具体的，</p>
<ul>
<li>Debug，调试代码时的输出，在系统实际运行时，一般不使用。</li>
<li>Warn，这种警告与调试时终端的warning类似，同样是调试代码时使用。</li>
<li>Info，报告系统当前的状态，当前执行的流程或接收的信息等。</li>
<li>Error和Fatal，输出系统的错误信息。</li>
</ul>
<p>上述的使用方法仅仅是个人理解，在开发中具体如何选择等级因人而异。项目中给出了除Fatal外的四种分级，实际使用了Debug，Info和Error三种。</p>
<p>超行、按天分文件逻辑，具体的，</p>
<ul>
<li>日志写入前会判断当前day是否为创建日志的时间，行数是否超过最大行限制<ul>
<li>若为创建日志时间，写入日志，否则按当前时间创建新log，更新创建时间和行数</li>
<li>若行数超过最大行限制，在当前日志的末尾加count&#x2F;max_lines为后缀创建新log</li>
</ul>
</li>
</ul>
<p>将系统信息格式化后输出，具体为：格式化时间 + 格式化内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">time_t</span> t = now.tv_sec;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sys_tm = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//日志分级</span></span><br><span class="line">    <span class="keyword">switch</span> (level)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[debug]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[warn]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[erro]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新现有行数</span></span><br><span class="line">    m_count++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//日志不是今天或写入的日志行数是最大行的倍数</span></span><br><span class="line">	<span class="comment">//m_split_lines为最大行数</span></span><br><span class="line">    <span class="keyword">if</span> (m_today != my_tm.tm_mday || m_count % m_split_lines == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> new_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">        <span class="type">char</span> tail[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式化日志名中的时间部分</span></span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">16</span>, <span class="string">&quot;%d_%02d_%02d_&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是时间不是今天,则创建今天的日志，更新m_today和m_count</span></span><br><span class="line">        <span class="keyword">if</span> (m_today != my_tm.tm_mday)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s&quot;</span>, dir_name, tail, log_name);</span><br><span class="line">            m_today = my_tm.tm_mday;</span><br><span class="line">            m_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//超过了最大行，在之前的日志名基础上加后缀, m_count/m_split_lines</span></span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s.%lld&quot;</span>, dir_name, tail, log_name, m_count / m_split_lines);</span><br><span class="line">        &#125;</span><br><span class="line">        m_fp = <span class="built_in">fopen</span>(new_log, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    va_list valst;</span><br><span class="line">	<span class="comment">//将传入的format参数赋值给valst，便于格式化输出</span></span><br><span class="line">    <span class="built_in">va_start</span>(valst, format);</span><br><span class="line"></span><br><span class="line">    string log_str;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入内容格式：时间 + 内容</span></span><br><span class="line">    <span class="comment">//时间格式化，snprintf成功返回写字符的总数，其中不包括结尾的null字符</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">snprintf</span>(m_buf, <span class="number">48</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s &quot;</span>,</span><br><span class="line">                     my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday,</span><br><span class="line">                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内容格式化，用于向字符串中打印数据、数据格式用户自定义，返回写入到字符数组str中的字符个数(不包含终止符)</span></span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(m_buf + n, m_log_buf_size - <span class="number">1</span>, format, valst);</span><br><span class="line">    m_buf[n + m] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    m_buf[n + m + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    log_str = m_buf;</span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若m_is_async为true表示不同步，默认为同步</span></span><br><span class="line">    <span class="comment">//若异步,则将日志信息加入阻塞队列,同步则加锁向文件中写</span></span><br><span class="line">    <span class="keyword">if</span> (m_is_async &amp;&amp; !m_log_queue-&gt;<span class="built_in">full</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_log_queue-&gt;<span class="built_in">push</span>(log_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">fputs</span>(log_str.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(valst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 11 数据库连接池</title>
    <url>/posts/4e56a6fd/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>什么是数据库连接池？</code></p>
<p>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化。通俗来说，池是资源的容器，本质上是对资源的复用。</p>
<p>顾名思义，连接池中的资源为一组数据库连接，由程序动态地对池中的连接进行使用，释放。</p>
<p>当系统开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配；当服务器处理完一个客户连接后,可以把相关的资源放回池中，无需执行系统调用释放资源。</p>
<p><code>数据库访问的一般流程是什么？</code></p>
<p>当系统需要访问数据库时，先系统创建数据库连接，完成数据库操作，然后系统断开数据库连接。</p>
<p><code>为什么要创建连接池？</code></p>
<p>从一般流程中可以看出，若系统需要频繁访问数据库，则需要频繁创建和断开数据库连接，而创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。</p>
<p>在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。</p>
<h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>池可以看做资源的容器，所以多种实现方法，比如数组、链表、队列等。这里，使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。</p>
<p>项目中的数据库模块分为两部分，其一是数据库连接池的定义，其二是利用连接池完成登录和注册的校验功能。具体的，工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还连接池。</p>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>本篇将介绍数据库连接池的定义，具体的涉及到单例模式创建、连接池代码实现、RAII机制释放数据库连接。</p>
<p><strong>单例模式创建</strong>，结合代码描述连接池的单例实现。</p>
<p><strong>连接池代码实现</strong>，结合代码对连接池的外部访问接口进行详解。</p>
<p><strong>RAII机制释放数据库连接</strong>，描述连接释放的封装逻辑。</p>
<h3 id="单例模式创建"><a href="#单例模式创建" class="headerlink" title="单例模式创建"></a>单例模式创建</h3><p>使用局部静态变量懒汉模式创建连接池。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//局部静态变量单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> connection_pool *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">connection_pool</span>();</span><br><span class="line">	~<span class="built_in">connection_pool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">connection_pool *<span class="title">connection_pool::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> connection_pool connPool;</span><br><span class="line">	<span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接池代码实现"><a href="#连接池代码实现" class="headerlink" title="连接池代码实现"></a>连接池代码实现</h3><p>连接池的定义中注释比较详细，这里仅对其实现进行解析。</p>
<p>连接池的功能主要有：初始化，获取连接、释放连接，销毁连接池。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong><span  style="color: #00ACC1; ">初始化</span></strong></h4><p>值得注意的是，销毁连接池没有直接被外部调用，而是通过RAII机制来完成自动释放；使用信号量实现多线程争夺连接的同步机制，这里将信号量初始化为数据库的连接总数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">connection_pool::<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;CurConn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;FreeConn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RAII机制销毁连接池</span></span><br><span class="line">connection_pool::~<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DestroyPool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">unsigned</span> <span class="type">int</span> MaxConn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化数据库信息</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;url = url;</span><br><span class="line">	<span class="keyword">this</span>-&gt;Port = Port;</span><br><span class="line">	<span class="keyword">this</span>-&gt;User = User;</span><br><span class="line">	<span class="keyword">this</span>-&gt;PassWord = PassWord;</span><br><span class="line">	<span class="keyword">this</span>-&gt;DatabaseName = DBName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建MaxConn条数据库连接</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line">		con = <span class="built_in">mysql_init</span>(con);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Error:&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(con);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		con = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(con);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新连接池和空闲连接数量</span></span><br><span class="line">		connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">		++FreeConn;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将信号量初始化为最大连接次数</span></span><br><span class="line">	reserve = <span class="built_in">sem</span>(FreeConn);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;MaxConn = FreeConn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取、释放连接"><a href="#获取、释放连接" class="headerlink" title="获取、释放连接"></a><strong><span  style="color: #00ACC1; ">获取、释放连接</span></strong></h4><p>当线程数量大于数据库连接数量时，使用信号量进行同步，每次取出连接，信号量原子减1，释放连接原子加1，若连接池内没有连接了，则阻塞等待。</p>
<p>另外，由于多线程操作连接池，会造成竞争，这里使用互斥锁完成同步，具体的同步机制均使用lock.h中封装好的类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">connection_pool::GetConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == connList.<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取出连接，信号量原子减1，为0则等待</span></span><br><span class="line">	reserve.<span class="built_in">wait</span>();</span><br><span class="line">	</span><br><span class="line">	lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">	con = connList.<span class="built_in">front</span>();</span><br><span class="line">	connList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里的两个变量，并没有用到，非常鸡肋...</span></span><br><span class="line">	--FreeConn;</span><br><span class="line">	++CurConn;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line">	<span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放当前使用的连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection_pool::ReleaseConnection</span><span class="params">(MYSQL *con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">	connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">	++FreeConn;</span><br><span class="line">	--CurConn;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放连接原子加1</span></span><br><span class="line">	reserve.<span class="built_in">post</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="销毁连接池"><a href="#销毁连接池" class="headerlink" title="销毁连接池"></a><strong><span  style="color: #00ACC1; ">销毁连接池</span></strong></h4><p>通过迭代器遍历连接池链表，关闭对应数据库连接，清空链表并重置空闲连接和现有连接数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//销毁数据库连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::DestroyPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lock.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span> (connList.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//通过迭代器遍历，关闭数据库连接</span></span><br><span class="line">		list&lt;MYSQL *&gt;::iterator it;</span><br><span class="line">		<span class="keyword">for</span> (it = connList.<span class="built_in">begin</span>(); it != connList.<span class="built_in">end</span>(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			MYSQL *con = *it;</span><br><span class="line">			<span class="built_in">mysql_close</span>(con);</span><br><span class="line">		&#125;</span><br><span class="line">		CurConn = <span class="number">0</span>;</span><br><span class="line">		FreeConn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//清空list</span></span><br><span class="line">		connList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		lock.<span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RAII机制释放数据库连接"><a href="#RAII机制释放数据库连接" class="headerlink" title="RAII机制释放数据库连接"></a>RAII机制释放数据库连接</h3><p>将数据库连接的获取与释放通过RAII机制封装，避免手动释放。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong><span  style="color: #00ACC1; ">定义</span></strong></h4><p>这里需要注意的是，在获取连接时，通过有参构造对传入的参数进行修改。其中数据库连接本身是指针类型，所以参数需要通过双指针才能对其进行修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connectionRAII</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//双指针对MYSQL *con修改</span></span><br><span class="line">	<span class="built_in">connectionRAII</span>(MYSQL **con, connection_pool *connPool);</span><br><span class="line">	~<span class="built_in">connectionRAII</span>();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL *conRAII;</span><br><span class="line">	connection_pool *poolRAII;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong><span  style="color: #00ACC1; ">实现</span></strong></h4><p>不直接调用获取和释放连接的接口，将其封装起来，通过RAII机制进行获取和释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">connectionRAII::<span class="built_in">connectionRAII</span>(MYSQL **SQL, connection_pool *connPool)&#123;</span><br><span class="line">	*SQL = connPool-&gt;<span class="built_in">GetConnection</span>();</span><br><span class="line">	</span><br><span class="line">	conRAII = *SQL;</span><br><span class="line">	poolRAII = connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::~<span class="built_in">connectionRAII</span>()&#123;</span><br><span class="line">	poolRAII-&gt;<span class="built_in">ReleaseConnection</span>(conRAII);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 12 注册登录</title>
    <url>/posts/5a9ef7ce/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>本项目中，使用数据库连接池实现服务器访问数据库的功能，使用POST请求完成注册和登录的校验工作，</p>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>本篇将介绍同步实现注册登录功能，具体的涉及到流程图，载入数据库表，提取用户名和密码，注册登录流程与页面跳转的的代码实现。</p>
<p><strong>流程图</strong>，描述服务器从报文中提取出用户名密码，并完成注册和登录校验后，实现页面跳转的逻辑。</p>
<p><strong>载入数据库表</strong>，结合代码将数据库中的数据载入到服务器中。</p>
<p><strong>提取用户名和密码</strong>，结合代码对报文进行解析，提取用户名和密码。</p>
<p><strong>注册登录流程</strong>，结合代码对描述服务器进行注册和登录校验的流程。</p>
<p><strong>页面跳转</strong>，结合代码对页面跳转机制进行详解。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a><strong><span  style="color: #00ACC1; ">流程图</span></strong></h3><p>具体的，描述了GET和POST请求下的页面跳转流程。</p>
<div align=center><img src="http://ww1.sinaimg.cn/large/005TJ2c7ly1gfk0gjrgcyj318y0f3774.jpg" height="350"/> </div>

<h4 id="载入数据库表"><a href="#载入数据库表" class="headerlink" title="载入数据库表"></a><strong><span  style="color: #00ACC1; ">载入数据库表</span></strong></h4><p>将数据库中的用户名和密码载入到服务器的map中来，map中的key为用户名，value为密码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//用户名和密码</span></span><br><span class="line">map&lt;string, string&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::initmysql_result</span><span class="params">(connection_pool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先从连接池中取一个连接</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;SELECT error:%s\n&quot;</span>, <span class="built_in">mysql_error</span>(mysql));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果集中的列数</span></span><br><span class="line">    <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        users[temp1] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提取用户名和密码"><a href="#提取用户名和密码" class="headerlink" title="提取用户名和密码"></a><strong><span  style="color: #00ACC1; ">提取用户名和密码</span></strong></h4><p>服务器端解析浏览器的请求报文，当解析为POST请求时，cgi标志位设置为1，并将请求报文的消息体赋值给m_string，进而提取出用户名和密码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断http请求是否被完整读入</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//POST请求中最后为输入的用户名和密码</span></span><br><span class="line">        m_string = text;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据标志判断是登录检测还是注册检测</span></span><br><span class="line"><span class="type">char</span> flag = m_url[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(m_url_real, m_url + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(m_real_file + len, m_url_real, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">free</span>(m_url_real);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将用户名和密码提取出来</span></span><br><span class="line"><span class="comment">//user=123&amp;password=123</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">100</span>], password[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以&amp;为分隔符，前面的为用户名</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">5</span>; m_string[i] != <span class="string">&#x27;&amp;&#x27;</span>; ++i)</span><br><span class="line">    name[i - <span class="number">5</span>] = m_string[i];</span><br><span class="line">name[i - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以&amp;为分隔符，后面的是密码</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = i + <span class="number">10</span>; m_string[i] != <span class="string">&#x27;\0&#x27;</span>; ++i, ++j)</span><br><span class="line">    password[j] = m_string[i];</span><br><span class="line">password[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="同步线程登录注册"><a href="#同步线程登录注册" class="headerlink" title="同步线程登录注册"></a><strong><span  style="color: #00ACC1; ">同步线程登录注册</span></strong></h4><p>通过m_url定位&#x2F;所在位置，根据&#x2F;后的第一个字符判断是登录还是注册校验。</p>
<ul>
<li>2<ul>
<li>登录校验</li>
</ul>
</li>
<li>3<ul>
<li>注册校验</li>
</ul>
</li>
</ul>
<p>根据校验结果，跳转对应页面。另外，对数据库进行操作时，需要通过锁来同步。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == m_SQLVerify)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是注册，先检测数据库中是否有重名的</span></span><br><span class="line">        <span class="comment">//没有重名的，进行增加数据</span></span><br><span class="line">        <span class="type">char</span> *sql_insert = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(sql_insert, <span class="string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(sql_insert, name);</span><br><span class="line">        <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;, &#x27;&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(sql_insert, password);</span><br><span class="line">        <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断map中能否找到重复的用户名</span></span><br><span class="line">        <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) == users.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//向数据库中插入数据时，需要通过锁来同步数据</span></span><br><span class="line">            m_lock.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">mysql_query</span>(mysql, sql_insert);</span><br><span class="line">            users.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, string&gt;(name, password));</span><br><span class="line">            m_lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//校验成功，跳转登录页面</span></span><br><span class="line">            <span class="keyword">if</span> (!res)</span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">			<span class="comment">//校验失败，跳转注册失败页面</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是登录，直接判断</span></span><br><span class="line">    <span class="comment">//若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) != users.<span class="built_in">end</span>() &amp;&amp; users[name] == password)</span><br><span class="line">            <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/welcome.html&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/logError.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a><strong><span  style="color: #00ACC1; ">页面跳转</span></strong></h4><p>通过m_url定位&#x2F;所在位置，根据&#x2F;后的第一个字符，使用分支语句实现页面跳转。具体的，</p>
<ul>
<li>0<ul>
<li>跳转注册页面，GET</li>
</ul>
</li>
<li>1<ul>
<li>跳转登录页面，GET</li>
</ul>
</li>
<li>5<ul>
<li>显示图片页面，POST</li>
</ul>
</li>
<li>6<ul>
<li>显示视频页面，POST</li>
</ul>
</li>
<li>7<ul>
<li>显示关注页面，POST</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到url中/所在位置，进而判断/后第一个字符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册页面</span></span><br><span class="line"><span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/register.html&quot;</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m_url_real);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录页面</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/log.html&quot;</span>); </span><br><span class="line">    <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m_url_real);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图片页面</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/picture.html&quot;</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m_url_real);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//视频页面</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/video.html&quot;</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m_url_real);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关注页面</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/fans.html&quot;</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m_url_real);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//否则发送url实际请求的文件</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 13 踩坑与面试题</title>
    <url>/posts/6b716db3/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>本篇是项目的最终篇，将介绍踩坑与面试题两部分。</p>
<p><strong>踩坑</strong>，描述做项目过程中遇到的问题与解决方案。</p>
<p><strong>面试题</strong>，介绍项目相关的知识点变种和真实面试题，<strong>但不会给出答案</strong>。</p>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>做项目过程中，肯定会遇到形形色色、大大小小的问题，但并不是所有问题都值得列出来探讨，这里仅列出个人认为有意义的问题。</p>
<p>具体的，包括大文件传输。</p>
<h4 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a><strong><span  style="color: #00ACC1; ">大文件传输</span></strong></h4><p>先看下之前的大文件传输，也就是游双书上的代码，发送数据只调用了writev函数，并对其返回值是否异常做了处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_have_send=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_to_send=m_write_idx;</span><br><span class="line">    <span class="keyword">if</span>(bytes_to_send==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=<span class="built_in">writev</span>(m_sockfd,m_iv,m_iv_count);</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd,m_sockfd,EPOLLOUT);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes_to_send-=temp;</span><br><span class="line">        bytes_have_send+=temp;</span><br><span class="line">        <span class="keyword">if</span>(bytes_to_send&lt;=bytes_have_send)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="keyword">if</span>(m_linger)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">init</span>();</span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际测试中发现，当请求小文件，也就是调用一次writev函数就可以将数据全部发送出去的时候，不会报错，此时不会再次进入while循环。</p>
<p>一旦请求服务器文件较大文件时，需要多次调用writev函数，便会出现问题，不是文件显示不全，就是无法显示。</p>
<p>对数据传输过程分析后，定位到writev的m_iv结构体成员有问题，每次传输后不会自动偏移文件指针和传输长度，还会按照原有指针和原有长度发送数据。</p>
<p>根据前面的基础API分析，我们知道writev以顺序iov[0]，iov[1]至iov[iovcnt-1]从缓冲区中聚集输出数据。项目中，申请了2个iov，其中iov[0]为存储报文状态行的缓冲区，iov[1]指向资源文件指针。</p>
<p>对上述代码做了修改如下：</p>
<ul>
<li>由于报文消息报头较小，第一次传输后，需要更新m_iv[1].iov_base和iov_len，m_iv[0].iov_len置成0，只传输文件，不用传输响应消息头</li>
<li>每次传输后都要更新下次传输的文件起始位置和长度</li>
</ul>
<p>更新后，大文件传输得到了解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newadd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_to_send == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="built_in">writev</span>(m_sockfd, m_iv, m_iv_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bytes_have_send += temp;</span><br><span class="line">            newadd = bytes_have_send - m_write_idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">                    m_iv[<span class="number">1</span>].iov_base = m_file_address + newadd;</span><br><span class="line">                    m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_have_send;</span><br><span class="line">                    m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len - bytes_have_send;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line">        <span class="keyword">if</span> (bytes_to_send &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_linger)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">init</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>包括项目介绍，线程池相关，并发模型相关，HTTP报文解析相关，定时器相关，日志相关，压测相关，综合能力等。</p>
<h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a><strong><span  style="color: #00ACC1; ">项目介绍</span></strong></h4><ul>
<li>为什么要做这样一个项目？</li>
<li>介绍下你的项目</li>
</ul>
<h4 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a><strong><span  style="color: #00ACC1; ">线程池相关</span></strong></h4><ul>
<li>手写线程池</li>
<li>线程的同步机制有哪些？</li>
<li>线程池中的工作线程是一直等待吗？</li>
<li>你的线程池工作线程处理完一个任务后的状态？</li>
<li>如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</li>
<li>如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</li>
</ul>
<h4 id="并发模型相关"><a href="#并发模型相关" class="headerlink" title="并发模型相关"></a><strong><span  style="color: #00ACC1; ">并发模型相关</span></strong></h4><ul>
<li>简单说一下服务器使用的并发模型？</li>
<li>reactor、proactor，主从reactor模型的区别？</li>
<li>你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</li>
</ul>
<h4 id="HTTP报文解析相关"><a href="#HTTP报文解析相关" class="headerlink" title="HTTP报文解析相关"></a><strong><span  style="color: #00ACC1; ">HTTP报文解析相关</span></strong></h4><ul>
<li>用了状态机啊，为什么要用状态机？</li>
<li>状态机的转移图画一下</li>
<li>https协议为什么安全？</li>
<li>https的ssl连接过程</li>
<li>GET和POST的区别</li>
</ul>
<h4 id="数据库登录注册相关"><a href="#数据库登录注册相关" class="headerlink" title="数据库登录注册相关"></a><strong><span  style="color: #00ACC1; ">数据库登录注册相关</span></strong></h4><ul>
<li>登录说一下？</li>
<li>你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）</li>
<li>登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？</li>
<li>用的mysql啊，redis了解吗？用过吗？</li>
</ul>
<h4 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a><strong><span  style="color: #00ACC1; ">定时器相关</span></strong></h4><ul>
<li>为什么要用定时器？</li>
<li>说一下定时器的工作原理</li>
<li>双向链表啊，删除和添加的时间复杂度说一下？还可以优化吗？</li>
<li>最小堆优化？说一下时间复杂度和工作原理</li>
</ul>
<h4 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a><strong><span  style="color: #00ACC1; ">日志相关</span></strong></h4><ul>
<li>说下你的日志系统的运行机制？</li>
<li>为什么要异步？和同步的区别是什么？</li>
<li>现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）</li>
</ul>
<h4 id="压测相关"><a href="#压测相关" class="headerlink" title="压测相关"></a><strong><span  style="color: #00ACC1; ">压测相关</span></strong></h4><ul>
<li>服务器并发量测试过吗？怎么测试的？</li>
<li>webbench是什么？介绍一下原理</li>
<li>测试的时候有没有遇到问题？</li>
</ul>
<h4 id="综合能力"><a href="#综合能力" class="headerlink" title="综合能力"></a><strong><span  style="color: #00ACC1; ">综合能力</span></strong></h4><ul>
<li>你的项目解决了哪些其他同类项目没有解决的问题？</li>
<li>说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？</li>
</ul>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 04 http连接处理（上）</title>
    <url>/posts/5ad337c1/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>
<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>在服务器项目中，http请求的处理与响应至关重要，关系到用户界面的跳转与反馈。这里，社长将其分为上、中、下三个部分来讲解，具体的：</p>
<ul>
<li>上篇，梳理基础知识，结合代码分析http类及请求接收</li>
<li>中篇，结合代码分析请求报文解析</li>
<li>下篇，结合代码分析请求报文响应</li>
</ul>
<p><code>基础知识方面</code>，包括epoll、HTTP报文格式、状态码和有限状态机。</p>
<p><code>代码分析方面</code>，首先对服务器端处理http请求的全部流程进行简要介绍，然后结合代码对http类及请求接收进行详细分析。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll涉及的知识较多，这里仅对API和基础知识作介绍。更多资料请查阅资料，或查阅<code>游双的Linux高性能服务器编程 第9章 I/O复用</code></p>
<h4 id="epoll-create函数"><a href="#epoll-create函数" class="headerlink" title="epoll_create函数"></a><strong><span  style="color: #00ACC1; ">epoll_create函数</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数，size不起作用。</p>
<h4 id="epoll-ctl函数"><a href="#epoll-ctl函数" class="headerlink" title="epoll_ctl函数"></a><strong><span  style="color: #00ACC1; ">epoll_ctl函数</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除</p>
<ul>
<li>epfd：为epoll_creat的句柄</li>
<li>op：表示动作，用3个宏来表示：<ul>
<li>EPOLL_CTL_ADD (注册新的fd到epfd)，</li>
<li>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</li>
<li>EPOLL_CTL_DEL (从epfd删除一个fd)；</li>
</ul>
</li>
<li>event：告诉内核需要监听的事件</li>
</ul>
<p>上述event是epoll_event结构体指针类型，表示内核所监听的事件，具体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line"><span class="type">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>events描述事件类型，其中epoll事件类型有以下几种<ul>
<li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
</li>
</ul>
<h4 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a><strong><span  style="color: #00ACC1; ">epoll_wait函数</span></strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span></span><br></pre></td></tr></table></figure>

<p>该函数用于等待所监控文件描述符上有事件的产生，返回就绪的文件描述符个数</p>
<ul>
<li>events：用来存内核得到事件的集合，</li>
<li>maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</li>
<li>timeout： 是超时时间<ul>
<li>-1：阻塞</li>
<li>0：立即返回，非阻塞</li>
<li><blockquote>
<p>0：指定毫秒</p>
</blockquote>
</li>
</ul>
</li>
<li>返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</li>
</ul>
<h4 id="select-x2F-poll-x2F-epoll"><a href="#select-x2F-poll-x2F-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a><strong><span  style="color: #00ACC1; ">select&#x2F;poll&#x2F;epoll</span></strong></h4><ul>
<li>调用函数<ul>
<li>select和poll都是一个函数，epoll是一组函数</li>
</ul>
</li>
<li>文件描述符数量<ul>
<li>select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐</li>
<li>poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目</li>
<li>epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效</li>
</ul>
</li>
<li>将文件描述符从用户传给内核<ul>
<li>select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</li>
<li>epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上</li>
</ul>
</li>
<li>内核判断就绪的文件描述符<ul>
<li>select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生</li>
<li>epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。</li>
<li>epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list</li>
</ul>
</li>
<li>应用程序索引就绪文件描述符<ul>
<li>select&#x2F;poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</li>
<li>epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可</li>
</ul>
</li>
<li>工作模式<ul>
<li>select和poll都只能工作在相对低效的LT模式下</li>
<li>epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。</li>
</ul>
</li>
<li>应用场景<ul>
<li>当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll</li>
<li>当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll</li>
<li>当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</li>
</ul>
</li>
</ul>
<h4 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a><strong><span  style="color: #00ACC1; ">ET、LT、EPOLLONESHOT</span></strong></h4><ul>
<li>LT水平触发模式<ul>
<li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li>
<li>当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理</li>
</ul>
</li>
<li>ET边缘触发模式<ul>
<li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li>
<li>必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现eagain</li>
</ul>
</li>
<li>EPOLLONESHOT<ul>
<li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li>
<li>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，<strong>当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</strong></li>
</ul>
</li>
</ul>
<h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p>HTTP报文分为请求报文和响应报文两种，每种报文必须按照特有格式生成，才能被浏览器端识别。</p>
<p>其中，浏览器端向服务器发送的为请求报文，服务器处理后返回给浏览器端的为响应报文。</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a><strong><span  style="color: #00ACC1; ">请求报文</span></strong></h4><p>HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</p>
<p>其中，请求分为两种，GET和POST，具体的：</p>
<ul>
<li><strong>GET</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET /<span class="number">562f</span>25980001b1b106000338.jpg HTTP/<span class="number">1.1</span></span><br><span class="line">Host:img.mukewang.com</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; WOW64)</span><br><span class="line">AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">51.0</span><span class="number">.2704</span><span class="number">.106</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept:image/webp,image<span class="comment">/*,*/</span>*;q=<span class="number">0.8</span></span><br><span class="line">Referer:http:<span class="comment">//www.imooc.com/</span></span><br><span class="line">Accept-Encoding:gzip, deflate, sdch</span><br><span class="line">Accept-Language:zh-CN,zh;q=<span class="number">0.8</span></span><br><span class="line">空行</span><br><span class="line">请求数据为空</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>POST</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">POST / HTTP1<span class="number">.1</span></span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/<span class="number">4.0</span> (compatible; MSIE <span class="number">6.0</span>; Windows NT <span class="number">5.1</span>; SV1; .NET CLR <span class="number">2.0</span><span class="number">.50727</span>; .NET CLR <span class="number">3.0</span><span class="number">.04506</span><span class="number">.648</span>; .NET CLR <span class="number">3.5</span><span class="number">.21022</span>)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:<span class="number">40</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">空行</span><br><span class="line">name=Professional%<span class="number">20</span>Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>请求行</strong>，用来说明请求类型,要访问的资源以及所使用的HTTP版本。<br>GET说明请求类型为GET，&#x2F;562f25980001b1b106000338.jpg(URL)为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</li>
<li><strong>请求头部</strong>，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。<ul>
<li>HOST，给出请求资源所在服务器的域名。</li>
<li>User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。</li>
<li>Accept，说明用户代理可处理的媒体类型。</li>
<li>Accept-Encoding，说明用户代理支持的内容编码。</li>
<li>Accept-Language，说明用户代理能够处理的自然语言集。</li>
<li>Content-Type，说明实现主体的媒体类型。</li>
<li>Content-Length，说明实现主体的大小。</li>
<li>Connection，连接管理，可以是Keep-Alive或close。</li>
</ul>
</li>
<li><strong>空行</strong>，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。</li>
<li><strong>请求数据</strong>也叫主体，可以添加任意的其他数据。</li>
</ul>
</blockquote>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a><strong><span  style="color: #00ACC1; ">响应报文</span></strong></h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Fri, <span class="number">22</span> May <span class="number">2009</span> <span class="number">06</span>:<span class="number">07</span>:<span class="number">21</span> GMT</span><br><span class="line">Content-Type: text/html; charset=UTF<span class="number">-8</span></span><br><span class="line">空行</span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>第一行为状态行，（HTTP&#x2F;1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。</li>
<li>消息报头，用来说明客户端要使用的一些附加信息。<br>第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text&#x2F;html),编码类型是UTF-8。</li>
<li>空行，消息报头后面的空行是必须的。</li>
<li>响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</li>
</ul>
</blockquote>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>HTTP有5种类型的状态码，具体的：</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求正常处理完毕。<ul>
<li>200 OK：客户端请求被正常处理。</li>
<li>206 Partial content：客户端进行了范围请求。</li>
</ul>
</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。<ul>
<li>301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</li>
<li>302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。</li>
</ul>
</li>
<li>4xx：客户端错误–请求有语法错误，服务器无法处理请求。<ul>
<li>400 Bad Request：请求报文存在语法错误。</li>
<li>403 Forbidden：请求被服务器拒绝。</li>
<li>404 Not Found：请求不存在，服务器上找不到请求的资源。</li>
</ul>
</li>
<li>5xx：服务器端错误–服务器处理请求出错。 <ul>
<li>500 Internal Server Error：服务器在执行请求时出现错误。</li>
</ul>
</li>
</ul>
<h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p>有限状态机，是一种抽象的理论模型，它能够把有限个变量描述的状态变化过程，以可构造可验证的方式呈现出来。比如，封闭的有向图。</p>
<p>有限状态机可以通过if-else,switch-case和函数指针来实现，从软件工程的角度看，主要是为了封装逻辑。</p>
<p>带有状态转移的有限状态机示例代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">STATE_MACHINE</span>()&#123;</span><br><span class="line">    State cur_State = type_A;</span><br><span class="line">	<span class="keyword">while</span>(cur_State != type_C)&#123;</span><br><span class="line">		Package _pack = <span class="built_in">getNewPackage</span>();</span><br><span class="line">		<span class="keyword">switch</span>()&#123;</span><br><span class="line">			<span class="keyword">case</span> type_A:</span><br><span class="line">				<span class="built_in">process_pkg_state_A</span>(_pack);</span><br><span class="line">				cur_State = type_B;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> type_B:</span><br><span class="line">				<span class="built_in">process_pkg_state_B</span>(_pack);</span><br><span class="line">				cur_State = type_C;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该状态机包含三种状态：type_A，type_B和type_C。其中，type_A是初始状态，type_C是结束状态。</p>
<p>状态机的当前状态记录在cur_State变量中，逻辑处理时，状态机先通过getNewPackage获取数据包，然后根据当前状态对数据进行处理，处理完后，状态机通过改变cur_State完成状态转移。</p>
<p>有限状态机一种逻辑单元内部的一种高效编程方法，在服务器编程中，服务器可以根据不同状态或者消息类型进行相应的处理逻辑，使得程序逻辑清晰易懂。</p>
<h3 id="http处理流程"><a href="#http处理流程" class="headerlink" title="http处理流程"></a>http处理流程</h3><p>首先对http报文处理的流程进行简要介绍，然后具体介绍http类的定义和服务器接收http请求的具体过程。</p>
<h4 id="http报文处理流程"><a href="#http报文处理流程" class="headerlink" title="http报文处理流程"></a><strong><span  style="color: #00ACC1; ">http报文处理流程</span></strong></h4><ul>
<li>浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。(<strong>本篇讲</strong>)</li>
<li>工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。(<strong>中篇讲</strong>)</li>
<li>解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。(<strong>下篇讲</strong>)</li>
</ul>
<h4 id="http类"><a href="#http类" class="headerlink" title="http类"></a><strong><span  style="color: #00ACC1; ">http类</span></strong></h4><p>这一部分代码在TinyWebServer&#x2F;http&#x2F;http_conn.h中，主要是http类的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_conn</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//设置读取文件的名称m_real_file大小</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> FILENAME_LEN=<span class="number">200</span>;</span><br><span class="line">		<span class="comment">//设置读缓冲区m_read_buf大小</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> READ_BUFFER_SIZE=<span class="number">2048</span>;</span><br><span class="line">		<span class="comment">//设置写缓冲区m_write_buf大小</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> WRITE_BUFFER_SIZE=<span class="number">1024</span>;</span><br><span class="line">		<span class="comment">//报文的请求方法，本项目只用到GET和POST</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">METHOD</span>&#123;GET=<span class="number">0</span>,POST,HEAD,PUT,DELETE,TRACE,OPTIONS,CONNECT,PATH&#125;;</span><br><span class="line">		<span class="comment">//主状态机的状态</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">CHECK_STATE</span>&#123;CHECK_STATE_REQUESTLINE=<span class="number">0</span>,CHECK_STATE_HEADER,CHECK_STATE_CONTENT&#125;;</span><br><span class="line">		<span class="comment">//报文解析的结果</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">HTTP_CODE</span>&#123;NO_REQUEST,GET_REQUEST,BAD_REQUEST,NO_RESOURCE,FORBIDDEN_REQUEST,FILE_REQUEST,INTERNAL_ERROR,CLOSED_CONNECTION&#125;;</span><br><span class="line">		<span class="comment">//从状态机的状态</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">LINE_STATUS</span>&#123;LINE_OK=<span class="number">0</span>,LINE_BAD,LINE_OPEN&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">http_conn</span>()&#123;&#125;</span><br><span class="line">        ~<span class="built_in">http_conn</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//初始化套接字地址，函数内部会调用私有方法init</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">const</span> sockaddr_in &amp;addr)</span></span>;</span><br><span class="line">		<span class="comment">//关闭http连接</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close=<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//读取浏览器端发来的全部数据</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">read_once</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//响应报文写入函数</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function">sockaddr_in *<span class="title">get_address</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;m_address;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//同步线程初始化数据库读取表</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">initmysql_result</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//CGI使用线程池初始化数据库表</span></span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">initresultFile</span><span class="params">(connection_pool *connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//从m_read_buf读取，并处理请求报文</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">process_read</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//向m_write_buf写入响应报文数据</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">process_write</span><span class="params">(HTTP_CODE ret)</span></span>;</span><br><span class="line">		<span class="comment">//主状态机解析报文中的请求行数据</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span></span>;</span><br><span class="line">		<span class="comment">//主状态机解析报文中的请求头数据</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">parse_headers</span><span class="params">(<span class="type">char</span> *text)</span></span>;</span><br><span class="line">		<span class="comment">//主状态机解析报文中的请求内容</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">parse_content</span><span class="params">(<span class="type">char</span> *text)</span></span>;</span><br><span class="line">		<span class="comment">//生成响应报文</span></span><br><span class="line">        <span class="function">HTTP_CODE <span class="title">do_request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//m_start_line是已经解析的字符</span></span><br><span class="line">		<span class="comment">//get_line用于将指针向后偏移，指向未处理的字符</span></span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">get_line</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_read_buf+m_start_line;&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从状态机读取一行，分析是请求报文的哪一部分</span></span><br><span class="line">        <span class="function">LINE_STATUS <span class="title">parse_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unmap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//根据响应报文格式，生成对应8个部分，以下函数均由do_request调用</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_response</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format,...)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_content</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* content)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_status_line</span><span class="params">(<span class="type">int</span> status,<span class="type">const</span> <span class="type">char</span>* title)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_headers</span><span class="params">(<span class="type">int</span> content_length)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">add_content_type</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_content_length</span><span class="params">(<span class="type">int</span> content_length)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_linger</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_blank_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> m_epollfd;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> m_user_count;</span><br><span class="line">		MYSQL *mysql;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> m_sockfd;</span><br><span class="line">        sockaddr_in m_address;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//存储读取的请求报文数据</span></span><br><span class="line">        <span class="type">char</span> m_read_buf[READ_BUFFER_SIZE];</span><br><span class="line">		<span class="comment">//缓冲区中m_read_buf中数据的最后一个字节的下一个位置</span></span><br><span class="line">        <span class="type">int</span> m_read_idx;</span><br><span class="line">		<span class="comment">//m_read_buf读取的位置m_checked_idx</span></span><br><span class="line">        <span class="type">int</span> m_checked_idx;</span><br><span class="line">		<span class="comment">//m_read_buf中已经解析的字符个数</span></span><br><span class="line">        <span class="type">int</span> m_start_line;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//存储发出的响应报文数据</span></span><br><span class="line">        <span class="type">char</span> m_write_buf[WRITE_BUFFER_SIZE];</span><br><span class="line">		<span class="comment">//指示buffer中的长度</span></span><br><span class="line">        <span class="type">int</span> m_write_idx;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//主状态机的状态</span></span><br><span class="line">        CHECK_STATE m_check_state;</span><br><span class="line">		<span class="comment">//请求方法</span></span><br><span class="line">        METHOD m_method;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//以下为解析请求报文中对应的6个变量</span></span><br><span class="line">		<span class="comment">//存储读取文件的名称</span></span><br><span class="line">        <span class="type">char</span> m_real_file[FILENAME_LEN];</span><br><span class="line">        <span class="type">char</span> *m_url;</span><br><span class="line">        <span class="type">char</span> *m_version;</span><br><span class="line">        <span class="type">char</span> *m_host;</span><br><span class="line">        <span class="type">int</span> m_content_length;</span><br><span class="line">        <span class="type">bool</span> m_linger;</span><br><span class="line">		</span><br><span class="line">        <span class="type">char</span> *m_file_address;		<span class="comment">//读取服务器上的文件地址</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">stat</span> m_file_stat;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">iovec</span> m_iv[<span class="number">2</span>];		<span class="comment">//io向量机制iovec</span></span><br><span class="line">        <span class="type">int</span> m_iv_count;</span><br><span class="line">		<span class="type">int</span> cgi;					<span class="comment">//是否启用的POST</span></span><br><span class="line">        <span class="type">char</span> *m_string;				<span class="comment">//存储请求头数据</span></span><br><span class="line">		<span class="type">int</span> bytes_to_send;			<span class="comment">//剩余发送字节数</span></span><br><span class="line">    	<span class="type">int</span> bytes_have_send;		<span class="comment">//已发送字节数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在http请求接收部分，会涉及到init和read_once函数，但init仅仅是对私有成员变量进行初始化，不用过多讲解。</p>
<p>这里，对read_once进行介绍。read_once读取浏览器端发送来的请求报文，直到无数据可读或对方关闭连接，读取到m_read_buffer中，并更新m_read_idx。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//循环读取客户数据，直到无数据可读或对方关闭连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_read_idx&gt;=READ_BUFFER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bytes_read=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//从套接字接收数据，存储在m_read_buf缓冲区</span></span><br><span class="line">        bytes_read=<span class="built_in">recv</span>(m_sockfd,m_read_buf+m_read_idx,READ_BUFFER_SIZE-m_read_idx,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(bytes_read==<span class="number">-1</span>)</span><br><span class="line">        &#123;	</span><br><span class="line">			<span class="comment">//非阻塞ET模式下，需要一次性将数据读完</span></span><br><span class="line">            <span class="keyword">if</span>(errno==EAGAIN||errno==EWOULDBLOCK)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bytes_read==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//修改m_read_idx的读取字节数</span></span><br><span class="line">        m_read_idx+=bytes_read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="epoll相关代码"><a href="#epoll相关代码" class="headerlink" title="epoll相关代码"></a><strong><span  style="color: #00ACC1; ">epoll相关代码</span></strong></h4><p>项目中epoll相关代码部分包括非阻塞模式、内核事件表注册事件、删除事件、重置EPOLLONESHOT事件四种。</p>
<ul>
<li>非阻塞模式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对文件描述符设置非阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内核事件表注册新事件，开启EPOLLONESHOT，针对客户端连接的描述符，listenfd不用开启</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ET</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LT</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内核事件表删除事件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重置EPOLLONESHOT事件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">int</span> ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ET</span></span><br><span class="line">    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LT</span></span><br><span class="line">    event.events = ev | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="服务器接收http请求"><a href="#服务器接收http请求" class="headerlink" title="服务器接收http请求"></a><strong><span  style="color: #00ACC1; ">服务器接收http请求</span></strong></h4><p>浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建MAX_FD个http类对象</span></span><br><span class="line">http_conn* users=<span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建内核事件表</span></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">assert</span>(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将listenfd放在epoll树上</span></span><br><span class="line"><span class="built_in">addfd</span>(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上述epollfd赋值给http类对象的m_epollfd属性</span></span><br><span class="line">http_conn::m_epollfd = epollfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//等待所监控文件描述符上有事件的产生</span></span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//对所有就绪事件进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理新到的客户连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"><span class="comment">//LT水平触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LT</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            users[connfd].<span class="built_in">init</span>(connfd, client_address);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ET非阻塞边缘触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ET</span></span><br><span class="line">			<span class="comment">//需要循环接收数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">                <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[connfd].<span class="built_in">init</span>(connfd, client_address);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//处理异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//服务器端关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理信号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//读入对应缓冲区</span></span><br><span class="line">            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//服务器关闭连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
  <entry>
    <title>【TinyWebServer】详解 - 06 http连接处理（下）</title>
    <url>/posts/3f776626/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>

<h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>上一篇详解中，我们对状态机和服务器解析请求报文进行了介绍。</p>
<p>本篇，我们将介绍服务器如何响应请求报文，并将该报文发送给浏览器端。首先介绍一些基础API，然后结合流程图和代码对服务器响应请求报文进行详解。</p>
<p><strong>基础API部分</strong>，介绍<code>stat</code>、<code>mmap</code>、<code>iovec</code>、<code>writev</code>。</p>
<p><strong>流程图部分</strong>，描述服务器端响应请求报文的逻辑，各模块间的关系。</p>
<p><strong>代码部分</strong>，结合代码对服务器响应请求报文进行详解。</p>
<h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><p>为了更好的源码阅读体验，这里提前对代码中使用的一些API进行简要介绍，更丰富的用法可以自行查阅资料。</p>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a><strong><span  style="color: #00ACC1; ">stat</span></strong></h4><p>stat函数用于取得指定文件的文件属性，并将文件属性存储在结构体stat里，这里仅对其中用到的成员进行介绍。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件属性，存储在statbuf中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">mode_t</span>    st_mode;        <span class="comment">/* 文件类型和权限 */</span></span><br><span class="line">   <span class="type">off_t</span>     st_size;        <span class="comment">/* 文件大小，字节数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a><strong><span  style="color: #00ACC1; ">mmap</span></strong></h4><p>用于将一个文件或其他对象映射到内存，提高文件的访问速度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span><span class="params">(<span class="type">void</span>* start,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span>* start,<span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址</li>
<li>length：映射区的长度</li>
<li>prot：期望的内存保护标志，不能与文件的打开模式冲突<ul>
<li>PROT_READ 表示页内容可以被读取</li>
</ul>
</li>
<li>flags：指定映射对象的类型，映射选项和映射页是否可以共享<ul>
<li>MAP_PRIVATE 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件</li>
</ul>
</li>
<li>fd：有效的文件描述符，一般是由open()函数返回</li>
<li>off_toffset：被映射对象内容的起点</li>
</ul>
<h4 id="iovec"><a href="#iovec" class="headerlink" title="iovec"></a><strong><span  style="color: #00ACC1; ">iovec</span></strong></h4><p>定义了一个向量元素，通常，这个结构用作一个多元素的数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;</span><br><span class="line">    <span class="type">void</span>      *iov_base;      <span class="comment">/* starting address of buffer */</span></span><br><span class="line">    <span class="type">size_t</span>    iov_len;        <span class="comment">/* size of buffer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>iov_base指向数据的地址</li>
<li>iov_len表示数据的长度</li>
</ul>
<h4 id="writev"><a href="#writev" class="headerlink" title="writev"></a><strong><span  style="color: #00ACC1; ">writev</span></strong></h4><p>writev函数用于在一次函数调用中写多个非连续缓冲区，有时也将这该函数称为聚集写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>filedes表示文件描述符</li>
<li>iov为前述io向量机制结构体iovec</li>
<li>iovcnt为结构体的个数</li>
</ul>
<p>若成功则返回已写的字节数，若出错则返回-1。<code>writev</code>以顺序<code>iov[0]</code>，<code>iov[1]</code>至<code>iov[iovcnt-1]</code>从缓冲区中聚集输出数据。<code>writev</code>返回输出的字节总数，通常，它应等于所有缓冲区长度之和。</p>
<p><strong>特别注意：</strong> 循环调用writev时，需要重新处理iovec中的指针和长度，该函数不会对这两个成员做任何处理。writev的返回值为已写的字节数，但这个返回值“实用性”并不高，因为参数传入的是iovec数组，计量单位是iovcnt，而不是字节数，我们仍然需要通过遍历iovec来计算新的基址，另外写入数据的“结束点”可能位于一个iovec的中间某个位置，因此需要调整临界iovec的io_base和io_len。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>浏览器端发出HTTP请求报文，服务器端接收该报文并调用<code>process_read</code>对其进行解析，根据解析结果<code>HTTP_CODE</code>，进入相应的逻辑和模块。</p>
<p>其中，服务器子线程完成报文的解析与响应；主线程监测读写事件，调用<code>read_once</code>和<code>http_conn::write</code>完成数据的读取与发送。</p>
<div align=center><img src="http://ww1.sinaimg.cn/large/005TJ2c7ly1gdl0fae0scj31do0gl41l.jpg" height="350"/> </div>

<h4 id="HTTP-CODE含义"><a href="#HTTP-CODE含义" class="headerlink" title="HTTP_CODE含义"></a><strong><span  style="color: #00ACC1; ">HTTP_CODE含义</span></strong></h4><p>表示HTTP请求的处理结果，在头文件中初始化了八种情形，在报文解析与响应中只用到了七种。</p>
<ul>
<li>NO_REQUEST<ul>
<li>请求不完整，需要继续读取请求报文数据</li>
<li>跳转主线程继续监测读事件</li>
</ul>
</li>
<li>GET_REQUEST<ul>
<li>获得了完整的HTTP请求</li>
<li>调用do_request完成请求资源映射</li>
</ul>
</li>
<li>NO_RESOURCE<ul>
<li>请求资源不存在</li>
<li>跳转process_write完成响应报文</li>
</ul>
</li>
<li>BAD_REQUEST<ul>
<li>HTTP请求报文有语法错误或请求资源为目录</li>
<li>跳转process_write完成响应报文</li>
</ul>
</li>
<li>FORBIDDEN_REQUEST<ul>
<li>请求资源禁止访问，没有读取权限</li>
<li>跳转process_write完成响应报文</li>
</ul>
</li>
<li>FILE_REQUEST<ul>
<li>请求资源可以正常访问</li>
<li>跳转process_write完成响应报文</li>
</ul>
</li>
<li>INTERNAL_ERROR<ul>
<li>服务器内部错误，该结果在主状态机逻辑switch的default下，一般不会触发</li>
</ul>
</li>
</ul>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="do-request"><a href="#do-request" class="headerlink" title="do_request"></a><strong><span  style="color: #00ACC1; ">do_request</span></strong></h4><p><code>process_read</code>函数的返回值是对请求的文件分析后的结果，一部分是语法错误导致的<code>BAD_REQUEST</code>，一部分是<code>do_request</code>的返回结果.该函数将网站根目录和<code>url</code>文件拼接，然后通过stat判断该文件属性。另外，为了提高访问速度，通过mmap进行映射，将普通文件映射到内存逻辑地址。</p>
<p>为了更好的理解请求资源的访问流程，这里对各种各页面跳转机制进行简要介绍。其中，浏览器网址栏中的字符，即<code>url</code>，可以将其抽象成<code>ip:port/xxx</code>，<code>xxx</code>通过<code>html</code>文件的<code>action</code>属性进行设置。</p>
<p>m_url为请求报文中解析出的请求资源，以&#x2F;开头，也就是<code>/xxx</code>，项目中解析后的m_url有8种情况。</p>
<ul>
<li>&#x2F;<ul>
<li>GET请求，跳转到judge.html，即欢迎访问页面</li>
</ul>
</li>
<li>&#x2F;0<ul>
<li>POST请求，跳转到register.html，即注册页面</li>
</ul>
</li>
<li>&#x2F;1<ul>
<li>POST请求，跳转到log.html，即登录页面</li>
</ul>
</li>
<li>&#x2F;2CGISQL.cgi<ul>
<li>POST请求，进行登录校验</li>
<li>验证成功跳转到welcome.html，即资源请求成功页面</li>
<li>验证失败跳转到logError.html，即登录失败页面</li>
</ul>
</li>
<li>&#x2F;3CGISQL.cgi<ul>
<li>POST请求，进行注册校验</li>
<li>注册成功跳转到log.html，即登录页面</li>
<li>注册失败跳转到registerError.html，即注册失败页面</li>
</ul>
</li>
<li>&#x2F;5<ul>
<li>POST请求，跳转到picture.html，即图片请求页面</li>
</ul>
</li>
<li>&#x2F;6<ul>
<li>POST请求，跳转到video.html，即视频请求页面</li>
</ul>
</li>
<li>&#x2F;7<ul>
<li>POST请求，跳转到fans.html，即关注页面</li>
</ul>
</li>
</ul>
<p>如果大家对上述设置方式不理解，不用担心。具体的登录和注册校验功能会在第12节进行详解，到时候还会针对html进行介绍。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//网站根目录，文件夹内存放请求的资源和跳转的html文件</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* doc_root=<span class="string">&quot;/home/qgy/github/ini_tinywebserver/root&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//将初始化的m_real_file赋值为网站根目录</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_real_file,doc_root);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(doc_root);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//找到m_url中/的位置</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现登录和注册校验</span></span><br><span class="line">    <span class="keyword">if</span>(cgi==<span class="number">1</span> &amp;&amp; (*(p+<span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> || *(p+<span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//根据标志判断是登录检测还是注册检测</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//同步线程登录校验</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//CGI多进程登录校验</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果请求资源为/0，表示跳转注册界面</span></span><br><span class="line">    <span class="keyword">if</span>(*(p+<span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">		<span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(m_url_real,<span class="string">&quot;/register.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将网站目录和/register.html进行拼接，更新到m_real_file中</span></span><br><span class="line">		<span class="built_in">strncpy</span>(m_real_file+len,m_url_real,<span class="built_in">strlen</span>(m_url_real));</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果请求资源为/1，表示跳转登录界面</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( *(p+<span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">		<span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(m_url_real,<span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将网站目录和/log.html进行拼接，更新到m_real_file中</span></span><br><span class="line">		<span class="built_in">strncpy</span>(m_real_file+len,m_url_real,<span class="built_in">strlen</span>(m_url_real));</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//如果以上均不符合，即不是登录和注册，直接将url与网站目录拼接</span></span><br><span class="line">		<span class="comment">//这里的情况是welcome界面，请求服务器上的一个图片</span></span><br><span class="line">    	<span class="built_in">strncpy</span>(m_real_file+len,m_url,FILENAME_LEN-len<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过stat获取请求资源文件信息，成功则将信息更新到m_file_stat结构体</span></span><br><span class="line">	<span class="comment">//失败返回NO_RESOURCE状态，表示资源不存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>(m_real_file,&amp;m_file_stat)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断文件的权限，是否可读，不可读则返回FORBIDDEN_REQUEST状态</span></span><br><span class="line">    <span class="keyword">if</span>(!(m_file_stat.st_mode&amp;S_IROTH))</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line">	<span class="comment">//判断文件类型，如果是目录，则返回BAD_REQUEST，表示请求报文有误</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(m_file_stat.st_mode))</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//以只读方式获取文件描述符，通过mmap将该文件映射到内存中</span></span><br><span class="line">	<span class="type">int</span> fd=<span class="built_in">open</span>(m_real_file,O_RDONLY);</span><br><span class="line">    m_file_address=(<span class="type">char</span>*)<span class="built_in">mmap</span>(<span class="number">0</span>,m_file_stat.st_size,PROT_READ,MAP_PRIVATE,fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//避免文件描述符的浪费和占用</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//表示请求文件存在，且可以访问</span></span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="process-write"><a href="#process-write" class="headerlink" title="process_write"></a><strong><span  style="color: #00ACC1; ">process_write</span></strong></h4><p>根据<code>do_request</code>的返回状态，服务器子线程调用<code>process_write</code>向<code>m_write_buf</code>中写入响应报文。</p>
<ul>
<li>add_status_line函数，添加状态行：http&#x2F;1.1 状态码 状态消息</li>
<li>add_headers函数添加消息报头，内部调用add_content_length和add_linger函数<ul>
<li>content-length记录响应报文长度，用于浏览器端判断服务器是否发送完数据</li>
<li>connection记录连接状态，用于告诉浏览器端保持长连接</li>
</ul>
</li>
<li>add_blank_line添加空行</li>
</ul>
<p>上述涉及的5个函数，均是内部调用<code>add_response</code>函数更新<code>m_write_idx</code>指针和缓冲区<code>m_write_buf</code>中的内容。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_response</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果写入内容超出m_write_buf大小则报错</span></span><br><span class="line">    <span class="keyword">if</span>(m_write_idx&gt;=WRITE_BUFFER_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义可变参数列表</span></span><br><span class="line">    va_list arg_list;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将变量arg_list初始化为传入参数</span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_list,format);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将数据format从可变参数列表写入缓冲区写，返回写入数据的长度</span></span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">vsnprintf</span>(m_write_buf+m_write_idx,WRITE_BUFFER_SIZE<span class="number">-1</span>-m_write_idx,format,arg_list);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//如果写入的数据长度超过缓冲区剩余空间，则报错</span></span><br><span class="line">	<span class="keyword">if</span>(len&gt;=(WRITE_BUFFER_SIZE<span class="number">-1</span>-m_write_idx))&#123;</span><br><span class="line">        <span class="built_in">va_end</span>(arg_list);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新m_write_idx位置</span></span><br><span class="line">    m_write_idx+=len;</span><br><span class="line">	<span class="comment">//清空可变参列表</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_list);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加状态行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">(<span class="type">int</span> status,<span class="type">const</span> <span class="type">char</span>* title)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s %d %s\r\n&quot;</span>,<span class="string">&quot;HTTP/1.1&quot;</span>,status,title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加消息报头，具体的添加文本长度、连接状态和空行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="type">int</span> content_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_content_length</span>(content_len);</span><br><span class="line">    <span class="built_in">add_linger</span>();</span><br><span class="line">    <span class="built_in">add_blank_line</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加Content-Length，表示响应报文的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="type">int</span> content_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Length:%d\r\n&quot;</span>,content_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加文本类型，这里是html</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content_type</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Type:%s\r\n&quot;</span>,<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加连接状态，通知浏览器端是保持连接还是关闭</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Connection:%s\r\n&quot;</span>,(m_linger==<span class="literal">true</span>)?<span class="string">&quot;keep-alive&quot;</span>:<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加空行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加文本content</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>,content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>响应报文分为两种，一种是请求文件的存在，通过<code>io</code>向量机制<code>iovec</code>，声明两个<code>iovec</code>，第一个指向<code>m_write_buf</code>，第二个指向<code>mmap</code>的地址<code>m_file_address</code>；一种是请求出错，这时候只申请一个<code>iovec</code>，指向<code>m_write_buf</code>。</p>
<ul>
<li>iovec是一个结构体，里面有两个元素，指针成员iov_base指向一个缓冲区，这个缓冲区是存放的是writev将要发送的数据。</li>
<li>成员iov_len表示实际写入的长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//内部错误，500</span></span><br><span class="line">        <span class="keyword">case</span> INTERNAL_ERROR:</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//状态行</span></span><br><span class="line">            <span class="built_in">add_status_line</span>(<span class="number">500</span>,error_500_title);</span><br><span class="line">			<span class="comment">//消息报头</span></span><br><span class="line">            <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_500_form));</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">add_content</span>(error_500_form))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//报文语法有误，404</span></span><br><span class="line">        <span class="keyword">case</span> BAD_REQUEST:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_status_line</span>(<span class="number">404</span>,error_404_title);</span><br><span class="line">            <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">add_content</span>(error_404_form))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//资源没有访问权限，403</span></span><br><span class="line">        <span class="keyword">case</span> FORBIDDEN_REQUEST:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_status_line</span>(<span class="number">403</span>,error_403_title);</span><br><span class="line">            <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">add_content</span>(error_403_form))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//文件存在，200</span></span><br><span class="line">        <span class="keyword">case</span> FILE_REQUEST:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_status_line</span>(<span class="number">200</span>,ok_200_title);</span><br><span class="line">			<span class="comment">//如果请求的资源存在</span></span><br><span class="line">            <span class="keyword">if</span>(m_file_stat.st_size!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add_headers</span>(m_file_stat.st_size);</span><br><span class="line">				<span class="comment">//第一个iovec指针指向响应报文缓冲区，长度指向m_write_idx</span></span><br><span class="line">                m_iv[<span class="number">0</span>].iov_base=m_write_buf;</span><br><span class="line">                m_iv[<span class="number">0</span>].iov_len=m_write_idx;</span><br><span class="line">				<span class="comment">//第二个iovec指针指向mmap返回的文件指针，长度指向文件大小</span></span><br><span class="line">                m_iv[<span class="number">1</span>].iov_base=m_file_address;</span><br><span class="line">                m_iv[<span class="number">1</span>].iov_len=m_file_stat.st_size;</span><br><span class="line">                m_iv_count=<span class="number">2</span>;</span><br><span class="line">				<span class="comment">//发送的全部数据为响应报文头部信息和文件大小</span></span><br><span class="line">				bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//如果请求的资源大小为0，则返回空白html文件</span></span><br><span class="line">                <span class="type">const</span> <span class="type">char</span>* ok_string=<span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">                <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">add_content</span>(ok_string))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//除FILE_REQUEST状态外，其余状态只申请一个iovec，指向响应报文缓冲区</span></span><br><span class="line">    m_iv[<span class="number">0</span>].iov_base=m_write_buf;</span><br><span class="line">    m_iv[<span class="number">0</span>].iov_len=m_write_idx;</span><br><span class="line">    m_iv_count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="http-conn-write"><a href="#http-conn-write" class="headerlink" title="http_conn::write"></a><strong><span  style="color: #00ACC1; ">http_conn::write</span></strong></h4><p>服务器子线程调用<code>process_write</code>完成响应报文，随后注册<code>epollout</code>事件。服务器主线程检测写事件，并调用<code>http_conn::write</code>函数将响应报文发送给浏览器端。</p>
<p>该函数具体逻辑如下：</p>
<p>在生成响应报文时初始化byte_to_send，包括头部信息和文件数据大小。通过writev函数循环发送响应报文数据，根据返回值更新byte_have_send和iovec结构体的指针和长度，并判断响应报文整体是否发送成功。</p>
<ul>
<li>若writev单次发送成功，更新byte_to_send和byte_have_send的大小，若响应报文整体发送成功,则取消mmap映射,并判断是否是长连接.<ul>
<li>长连接重置http类实例，注册读事件，不关闭连接，</li>
<li>短连接直接关闭连接</li>
</ul>
</li>
<li>若writev单次发送不成功，判断是否是写缓冲区满了。<ul>
<li>若不是因为缓冲区满了而失败，取消mmap映射，关闭连接</li>
<li>若eagain则满了，更新iovec结构体的指针和长度，并注册写事件，等待下一次写事件触发（当写缓冲区从不可写变为可写，触发epollout），因此在此期间无法立即接收到同一用户的下一请求，但可以保证连接的完整性。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newadd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若要发送的数据长度为0</span></span><br><span class="line">	<span class="comment">//表示响应报文为空，一般不会出现这种情况</span></span><br><span class="line">    <span class="keyword">if</span>(bytes_to_send==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">		<span class="comment">//将响应报文的状态行、消息头、空行和响应正文发送给浏览器端</span></span><br><span class="line">        temp=<span class="built_in">writev</span>(m_sockfd,m_iv,m_iv_count);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//正常发送，temp为发送的字节数</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//更新已发送字节</span></span><br><span class="line">            bytes_have_send += temp;</span><br><span class="line">			<span class="comment">//偏移文件iovec的指针</span></span><br><span class="line">            newadd = bytes_have_send - m_write_idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//判断缓冲区是否满了</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//第一个iovec头部信息的数据已发送完，发送第二个iovec数据</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)</span><br><span class="line">                &#123;</span><br><span class="line">					<span class="comment">//不再继续发送头部信息</span></span><br><span class="line">                    m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">                    m_iv[<span class="number">1</span>].iov_base = m_file_address + newadd;</span><br><span class="line">                    m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//继续发送第一个iovec头部信息的数据</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_to_send;</span><br><span class="line">                    m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len - bytes_have_send;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//重新注册写事件</span></span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果发送失败，但不是缓冲区问题，取消映射</span></span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新已发送字节数</span></span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断条件，数据已全部发送完</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_send &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//在epoll树上重置EPOLLONESHOT事件</span></span><br><span class="line">            <span class="built_in">modfd</span>(m_epollfd,m_sockfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//浏览器的请求为长连接</span></span><br><span class="line">            <span class="keyword">if</span>(m_linger)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//重新初始化HTTP对象</span></span><br><span class="line">	            <span class="built_in">init</span>();</span><br><span class="line">	            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书中原代码的write函数不严谨，这里对其中的Bug进行了修复，可以正常传输大文件。</p>
<p>后续，我会写一篇推文，对大文件传输Bug定位、解决思路的代码实现进行介绍。</p>
<p>完。</p>
]]></content>
      <categories>
        <category>TinyWebServer</category>
      </categories>
  </entry>
</search>
